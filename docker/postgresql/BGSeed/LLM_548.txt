CREATE TABLE employees (
    id SERIAL PRIMARY KEY,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    hire_date DATE,
    salary DECIMAL(10, 2),
    department_id INTEGER
);

CREATE TABLE departments (
    id SERIAL PRIMARY KEY,
    name VARCHAR(50),
    location VARCHAR(50)
);

ALTER TABLE employees ADD CONSTRAINT fk_department
    FOREIGN KEY (department_id)
    REFERENCES departments (id);

INSERT INTO departments (name, location) VALUES
    ('Sales', 'New York'),
    ('Marketing', 'Los Angeles'),
    ('Engineering', 'San Francisco');

INSERT INTO employees (first_name, last_name, hire_date, salary, department_id) VALUES
    ('John', 'Doe', '2020-01-15', 60000.00, 1),
    ('Jane', 'Smith', '2021-03-01', 75000.00, 2),
    ('Peter', 'Jones', '2022-05-10', 90000.00, 3);

SELECT * FROM employees WHERE salary > 70000;

UPDATE employees SET salary = 80000.00 WHERE id = 2;

DELETE FROM employees WHERE id = 1;

CREATE INDEX idx_last_name ON employees (last_name);

CREATE VIEW high_earners AS
SELECT first_name, last_name, salary
FROM employees
WHERE salary > 75000;

SELECT * FROM high_earners;

CREATE FUNCTION get_employee_count(dept_id INTEGER)
RETURNS INTEGER AS $$
BEGIN
    RETURN (SELECT COUNT(*) FROM employees WHERE department_id = dept_id);
END;
$$ LANGUAGE plpgsql;

SELECT get_employee_count(2);

-- Test window functions
SELECT
    first_name,
    last_name,
    salary,
    RANK() OVER (ORDER BY salary DESC) as salary_rank
FROM employees;

-- Test common table expressions (CTEs)
WITH SalaryStats AS (
    SELECT AVG(salary) as avg_salary, MAX(salary) as max_salary FROM employees
)
SELECT first_name, last_name, salary, (SELECT avg_salary FROM SalaryStats) as avg_salary
FROM employees
WHERE salary > (SELECT avg_salary FROM SalaryStats);

-- Test JSON functions
SELECT json_build_object('name', first_name, 'salary', salary) FROM employees;

-- Test array functions
CREATE TABLE employee_skills (
    employee_id INTEGER REFERENCES employees(id),
    skills TEXT[]
);
INSERT INTO employee_skills (employee_id, skills) VALUES (2, ARRAY['SQL', 'Python', 'Data Analysis']);
SELECT skills[1] FROM employee_skills WHERE employee_id = 2;
SELECT array_length(skills, 1) FROM employee_skills WHERE employee_id = 2;

-- Test date/time functions
SELECT CURRENT_DATE, CURRENT_TIME, NOW();
SELECT AGE(hire_date) FROM employees;

-- Test string functions
SELECT UPPER(first_name), LOWER(last_name) FROM employees;
SELECT SUBSTRING(first_name FROM 1 FOR 3) FROM employees;

-- Test aggregate functions
SELECT AVG(salary), MAX(salary), MIN(salary), SUM(salary), COUNT(*) FROM employees;

-- Test GROUP BY and HAVING
SELECT department_id, AVG(salary) FROM employees GROUP BY department_id HAVING AVG(salary) > 70000;

-- Test CASE statement
SELECT first_name,
       CASE
           WHEN salary > 80000 THEN 'High'
           WHEN salary > 60000 THEN 'Medium'
           ELSE 'Low'
       END AS salary_level
FROM employees;

-- Test recursive CTE
WITH RECURSIVE NumberSeries AS (
  SELECT 1 AS n
  UNION ALL
  SELECT n + 1 FROM NumberSeries WHERE n < 10
)
SELECT n FROM NumberSeries;

-- Test generate_series function
SELECT generate_series(1, 5);

-- Test unnest function
SELECT unnest(ARRAY['a','b','c']);

-- Test NULLIF function
SELECT NULLIF(10, 10);
SELECT NULLIF(10, 5);

-- Test COALESCE function
SELECT COALESCE(NULL, 'Default Value');
SELECT COALESCE('Existing Value', 'Default Value');

-- Test casting
SELECT CAST('123' AS INTEGER);
SELECT '456'::INTEGER;

-- Test LIKE operator
SELECT * FROM employees WHERE first_name LIKE 'J%';

-- Test ILIKE operator (case-insensitive LIKE)
SELECT * FROM employees WHERE first_name ILIKE 'j%';

-- Test SIMILAR TO operator
SELECT * FROM employees WHERE first_name SIMILAR TO '(J|P)%';

-- Test regular expressions
SELECT * FROM employees WHERE first_name ~ '^[JP].*';

-- Test transactions
BEGIN;
UPDATE employees SET salary = salary * 1.10 WHERE department_id = 1;
-- Simulate an error
-- ROLLBACK;
COMMIT;

--Test materialized view
CREATE MATERIALIZED VIEW mv_emp_dept AS
SELECT e.first_name, d.name AS department_name
FROM employees e
JOIN departments d ON e.department_id = d.id;

REFRESH MATERIALIZED VIEW mv_emp_dept;

SELECT * FROM mv_emp_dept;