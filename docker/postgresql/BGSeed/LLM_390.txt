CREATE EXTENSION IF NOT EXISTS pgcrypto;

CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100),
    created_at TIMESTAMPTZ DEFAULT NOW(),
    password_hash TEXT,
    is_active BOOLEAN DEFAULT TRUE,
    profile_data JSONB
);

CREATE TABLE products (
    product_id SERIAL PRIMARY KEY,
    product_name VARCHAR(100) NOT NULL,
    description TEXT,
    price DECIMAL(10, 2) NOT NULL CHECK (price > 0),
    created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id),
    order_date TIMESTAMPTZ DEFAULT NOW(),
    total_amount DECIMAL(10, 2) NOT NULL CHECK (total_amount >= 0)
);

CREATE TABLE order_items (
    order_item_id SERIAL PRIMARY KEY,
    order_id INTEGER REFERENCES orders(order_id),
    product_id INTEGER REFERENCES products(product_id),
    quantity INTEGER NOT NULL CHECK (quantity > 0),
    price DECIMAL(10, 2) NOT NULL CHECK (price > 0)
);

INSERT INTO users (username, email, password_hash, profile_data) VALUES
('testuser1', 'test1@example.com', crypt('password123', gen_salt('bf')), '{"age": 30, "city": "New York"}'),
('testuser2', 'test2@example.com', crypt('securepass', gen_salt('bf')), '{"age": 25, "city": "Los Angeles"}');

INSERT INTO products (product_name, description, price) VALUES
('Awesome Widget', 'A really awesome widget.', 19.99),
('Deluxe Gadget', 'The ultimate gadget for your needs.', 49.99);

INSERT INTO orders (user_id, total_amount) VALUES
(1, 39.98),
(2, 99.98);

INSERT INTO order_items (order_id, product_id, quantity, price) VALUES
(1, 1, 2, 19.99),
(2, 2, 2, 49.99);

SELECT * FROM users WHERE age > 20;

UPDATE users SET email = 'newemail@example.com' WHERE username = 'testuser1';

DELETE FROM products WHERE product_name = 'Awesome Widget';

SELECT u.username, o.order_date, oi.quantity
FROM users u
JOIN orders o ON u.id = o.user_id
JOIN order_items oi ON o.order_id = oi.order_id;

SELECT jsonb_path_exists(profile_data, '$.city') FROM users;

CREATE VIEW active_users AS SELECT username, email FROM users WHERE is_active = TRUE;

ALTER TABLE users ADD COLUMN last_login TIMESTAMPTZ;

UPDATE users SET last_login = NOW() - INTERVAL '1 day' WHERE username = 'testuser1';

CREATE INDEX idx_users_username ON users (username);

-- Demonstrating WITH RECURSIVE
WITH RECURSIVE employee_hierarchy AS (
  SELECT id, username, 0 AS level
  FROM users
  WHERE id = 1
  UNION ALL
  SELECT e.id, e.username, eh.level + 1
  FROM users e
  JOIN employee_hierarchy eh ON e.id = eh.id  --Self-join; this is just for demonstration
)
SELECT * FROM employee_hierarchy;

CREATE TABLE data_table (
    id SERIAL PRIMARY KEY,
    value INTEGER NOT NULL,
    value_squared INTEGER GENERATED ALWAYS AS (value * value) STORED
);

INSERT INTO data_table (value) VALUES (5), (10);

SELECT * FROM data_table;

CREATE TABLE test_table (
  id SERIAL PRIMARY KEY,
  col1 TEXT,
  col2 INTEGER
);

INSERT INTO test_table (col1, col2) VALUES ('test1', 1), ('test2', 2);

ANALYZE test_table;

SELECT relname, attname, correlation FROM pg_stats WHERE tablename = 'test_table';

CREATE FUNCTION increment(i INTEGER) RETURNS INTEGER AS $$
        BEGIN
                RETURN i + 1;
        END;
$$ LANGUAGE plpgsql;

SELECT increment(5);

CREATE AGGREGATE myavg (numeric)
(
    sfunc = numeric_add,
    stype = numeric,
    initcond = '0',
    finalfunc = numeric_avg
);

SELECT myavg(price) from products;