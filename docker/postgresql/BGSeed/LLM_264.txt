CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    description TEXT,
    price DECIMAL(10, 2) NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

INSERT INTO products (name, description, price) VALUES
('Product A', 'Description for Product A', 19.99),
('Product B', 'Description for Product B', 29.99),
('Product C', 'Description for Product C', 39.99),
('Product D', 'Description for Product D', 49.99),
('Product E', 'Description for Product E', 59.99);

CREATE INDEX idx_products_name ON products (name);

CREATE TYPE mood AS ENUM ('sad', 'ok', 'happy');

CREATE TABLE person (
    name text,
    current_mood mood
);

INSERT INTO person VALUES ('Moe', 'happy');
INSERT INTO person VALUES ('Larry', 'sad');
INSERT INTO person VALUES ('Curly', 'ok');

SELECT * FROM person WHERE current_mood = 'happy';

CREATE TABLE inventory (
    product_id INTEGER REFERENCES products(id),
    quantity INTEGER NOT NULL CHECK (quantity >= 0),
    last_stock_update DATE
);

INSERT INTO inventory (product_id, quantity, last_stock_update) VALUES
(1, 100, '2024-01-01'),
(2, 50, '2024-01-05'),
(3, 75, '2024-01-10'),
(4, 25, '2024-01-15'),
(5, 120, '2024-01-20');

CREATE VIEW product_availability AS
SELECT
    p.name,
    i.quantity,
    CASE
        WHEN i.quantity > 0 THEN 'In Stock'
        ELSE 'Out of Stock'
    END AS availability
FROM
    products p
JOIN
    inventory i ON p.id = i.product_id;

SELECT * FROM product_availability;

CREATE FUNCTION update_product_price(product_name VARCHAR(255), new_price DECIMAL(10, 2))
RETURNS VOID AS $$
BEGIN
    UPDATE products SET price = new_price WHERE name = product_name;
    UPDATE products SET updated_at = NOW() WHERE name = product_name;
END;
$$ LANGUAGE plpgsql;

SELECT update_product_price('Product A', 24.99);

SELECT * FROM products WHERE name = 'Product A';

CREATE TABLE log_table (
    log_id SERIAL PRIMARY KEY,
    log_message TEXT,
    log_time TIMESTAMP WITHOUT TIME ZONE DEFAULT (NOW() AT TIME ZONE 'UTC')
);

CREATE TRIGGER product_update_trigger
AFTER UPDATE ON products
FOR EACH ROW
EXECUTE FUNCTION pg_notify('product_updates', 'Product updated');

LISTEN product_updates;

UPDATE products SET price = 25.99 WHERE id = 1;

UNLISTEN product_updates;

CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    customer_name VARCHAR(255) NOT NULL,
    order_date DATE NOT NULL,
    total_amount DECIMAL(10, 2) NOT NULL
);

INSERT INTO orders (customer_name, order_date, total_amount) VALUES
('Customer X', '2024-02-01', 100.00),
('Customer Y', '2024-02-05', 200.00),
('Customer Z', '2024-02-10', 150.00);

CREATE TABLE order_items (
    item_id SERIAL PRIMARY KEY,
    order_id INTEGER REFERENCES orders(order_id),
    product_id INTEGER REFERENCES products(id),
    quantity INTEGER NOT NULL,
    price DECIMAL(10, 2) NOT NULL
);

INSERT INTO order_items (order_id, product_id, quantity, price) VALUES
(1, 1, 2, 19.99),
(1, 2, 1, 29.99),
(2, 3, 3, 39.99),
(3, 4, 1, 49.99),
(3, 5, 2, 59.99);

SELECT * FROM orders;
SELECT * FROM order_items;

CREATE TABLE sales (
    sale_id SERIAL PRIMARY KEY,
    product_id INTEGER REFERENCES products(id),
    sale_date DATE NOT NULL,
    quantity INTEGER NOT NULL,
    price DECIMAL(10, 2) NOT NULL
);

INSERT INTO sales (product_id, sale_date, quantity, price) VALUES
(1, '2024-02-15', 5, 19.99),
(2, '2024-02-20', 3, 29.99),
(3, '2024-02-25', 2, 39.99);

SELECT * FROM sales;

CREATE OR REPLACE FUNCTION calculate_total_sales(start_date DATE, end_date DATE)
RETURNS DECIMAL AS $$
DECLARE
    total_sales DECIMAL;
BEGIN
    SELECT SUM(quantity * price) INTO total_sales
    FROM sales
    WHERE sale_date BETWEEN start_date AND end_date;
    RETURN total_sales;
END;
$$ LANGUAGE plpgsql;

SELECT calculate_total_sales('2024-02-01', '2024-02-28');

CREATE TABLE products_backup AS SELECT * FROM products;

CREATE SEQUENCE product_id_seq START WITH 100;
ALTER TABLE products ALTER COLUMN id SET DEFAULT nextval('product_id_seq');
INSERT INTO products (name, description, price) VALUES ('Product F', 'Another product', 69.99);
SELECT * FROM products WHERE name = 'Product F';

ALTER TABLE products ADD COLUMN category VARCHAR(50);
UPDATE products SET category = 'Electronics' WHERE id IN (1, 2);
UPDATE products SET category = 'Home Goods' WHERE id IN (3, 4);
UPDATE products SET category = 'Other' WHERE id IN (5, 6);
SELECT * FROM products;

CREATE MATERIALIZED VIEW mv_product_sales AS
SELECT p.name, SUM(s.quantity) AS total_quantity
FROM products p JOIN sales s ON p.id = s.product_id
GROUP BY p.name;

REFRESH MATERIALIZED VIEW mv_product_sales;
SELECT * FROM mv_product_sales;

-- Generate a random UUID
SELECT gen_random_uuid();

-- Generate a random integer
SELECT floor(random() * 100 + 1);

-- JSON operations
CREATE TABLE json_test (data jsonb);
INSERT INTO json_test VALUES ('{"a": 1, "b": 2}');
SELECT data -> 'a' FROM json_test;

-- Using window functions
SELECT name, price, ROW_NUMBER() OVER (ORDER BY price DESC) FROM products;

-- Create a table with a generated column
CREATE TABLE generated_test (
  a INT,
  b INT GENERATED ALWAYS AS (a * 2) STORED
);
INSERT INTO generated_test (a) VALUES (10);
SELECT * FROM generated_test;