SET client_min_messages TO 'warning';

-- Drop existing objects to ensure a clean slate
DROP TABLE IF EXISTS products CASCADE;
DROP TABLE IF EXISTS orders CASCADE;
DROP TABLE IF EXISTS customers CASCADE;
DROP FUNCTION IF EXISTS check_product_availability(integer, integer);
DROP FUNCTION IF EXISTS get_customer_country(integer);
DROP POLICY IF EXISTS product_availability_policy ON products;
DROP POLICY IF EXISTS customer_country_policy ON customers;
DROP USER IF EXISTS sales_user;
DROP ROLE IF EXISTS order_manager;

RESET client_min_messages;

-- Create a role for managing orders
CREATE ROLE order_manager NOLOGIN;

-- Create a user for sales with a specific password
CREATE USER sales_user WITH PASSWORD 'secure_password';

-- Grant the sales_user role membership in the order_manager role
GRANT order_manager TO sales_user;

-- Table for products
CREATE TABLE products (
    product_id SERIAL PRIMARY KEY,
    product_name VARCHAR(100) NOT NULL,
    price DECIMAL(10, 2) NOT NULL CHECK (price > 0),
    stock_quantity INTEGER NOT NULL CHECK (stock_quantity >= 0),
    category VARCHAR(50)
);

-- Table for customers
CREATE TABLE customers (
    customer_id SERIAL PRIMARY KEY,
    first_name VARCHAR(50) NOT NULL,
    last_name VARCHAR(50) NOT NULL,
    email VARCHAR(100) UNIQUE,
    country VARCHAR(50)
);

-- Table for orders
CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    customer_id INTEGER REFERENCES customers(customer_id),
    product_id INTEGER REFERENCES products(product_id),
    order_date DATE NOT NULL DEFAULT CURRENT_DATE,
    quantity INTEGER NOT NULL CHECK (quantity > 0),
    total_amount DECIMAL(10, 2)
);

-- Insert sample data into products
INSERT INTO products (product_name, price, stock_quantity, category) VALUES
    ('Laptop', 1200.00, 50, 'Electronics'),
    ('Office Chair', 250.00, 200, 'Furniture'),
    ('Wireless Mouse', 25.00, 500, 'Electronics'),
    ('Ergonomic Keyboard', 75.00, 300, 'Electronics'),
    ('Desk Lamp', 50.00, 150, 'Furniture');

-- Insert sample data into customers
INSERT INTO customers (first_name, last_name, email, country) VALUES
    ('Alice', 'Smith', 'alice.smith@example.com', 'USA'),
    ('Bob', 'Johnson', 'bob.johnson@example.com', 'Canada'),
    ('Charlie', 'Brown', 'charlie.brown@example.com', 'UK'),
    ('David', 'Garcia', 'david.garcia@example.com', 'USA'),
    ('Eve', 'Wilson', 'eve.wilson@example.com', 'Germany');

-- Insert sample data into orders
INSERT INTO orders (customer_id, product_id, quantity) VALUES
    (1, 1, 2),
    (2, 2, 1),
    (3, 3, 5),
    (4, 4, 3),
    (5, 5, 10);

-- Update total_amount in orders based on product price and quantity
UPDATE orders
SET total_amount = p.price * o.quantity
FROM products p
WHERE orders.product_id = p.product_id;

-- Function to check product availability before placing an order
CREATE OR REPLACE FUNCTION check_product_availability(p_product_id INTEGER, p_quantity INTEGER)
RETURNS BOOLEAN AS $$
DECLARE
    v_stock_quantity INTEGER;
BEGIN
    SELECT stock_quantity INTO v_stock_quantity
    FROM products
    WHERE product_id = p_product_id;

    IF v_stock_quantity >= p_quantity THEN
        RETURN TRUE;
    ELSE
        RETURN FALSE;
    END IF;
END;
$$ LANGUAGE plpgsql;

-- Test the function
SELECT check_product_availability(1, 10);

-- Function to get customer's country
CREATE OR REPLACE FUNCTION get_customer_country(p_customer_id INTEGER)
RETURNS VARCHAR(50) AS $$
DECLARE
    v_country VARCHAR(50);
BEGIN
    SELECT country INTO v_country
    FROM customers
    WHERE customer_id = p_customer_id;

    RETURN v_country;
END;
$$ LANGUAGE plpgsql;

-- Test the function
SELECT get_customer_country(1);

-- Row Level Security Policies
ALTER TABLE products ENABLE ROW LEVEL SECURITY;
ALTER TABLE customers ENABLE ROW LEVEL SECURITY;
ALTER TABLE orders ENABLE ROW LEVEL SECURITY;

-- Policy to restrict product visibility based on stock quantity (example)
CREATE POLICY product_availability_policy ON products
FOR SELECT
USING (stock_quantity > 0);

-- Policy to restrict customer visibility based on country (example)
CREATE POLICY customer_country_policy ON customers
FOR SELECT
USING (country = 'USA');

-- Grant SELECT privilege to sales_user on products subject to RLS
GRANT SELECT ON products TO sales_user;

-- Grant SELECT, INSERT, UPDATE, DELETE to order_manager on orders
GRANT SELECT, INSERT, UPDATE, DELETE ON orders TO order_manager;
GRANT USAGE, SELECT ON SEQUENCE orders_order_id_seq TO order_manager;

-- Switch to sales_user and test access
SET SESSION AUTHORIZATION sales_user;

-- Try to select products (subject to RLS)
SELECT * FROM products;

-- Try to insert a new order (should work if granted to order_manager)
INSERT INTO orders (customer_id, product_id, quantity) VALUES (1, 1, 1);

-- Switch back to the original user
RESET SESSION AUTHORIZATION;

-- Test INSERT with ON CONFLICT DO UPDATE
INSERT INTO customers (first_name, last_name, email, country) VALUES
    ('Alice', 'Smith', 'alice.smith@example.com', 'Canada')
    ON CONFLICT (email) DO UPDATE SET country = EXCLUDED.country;

-- Test foreign key constraint
INSERT INTO orders (customer_id, product_id, quantity) VALUES (999, 1, 1);  -- Invalid customer_id

-- Test CHECK constraint
INSERT INTO products (product_name, price, stock_quantity, category) VALUES ('Invalid Product', -10, 10, 'Test');

-- Test UNIQUE constraint
INSERT INTO customers (first_name, last_name, email, country) VALUES ('Duplicate', 'Email', 'alice.smith@example.com', 'UK');

-- Test CREATE INDEX CONCURRENTLY
CREATE INDEX CONCURRENTLY idx_products_category ON products (category);

-- Test TRUNCATE TABLE
TRUNCATE TABLE orders;

-- Test CREATE VIEW
CREATE VIEW product_summary AS
SELECT category, COUNT(*) AS product_count, AVG(price) AS average_price
FROM products
GROUP BY category;

SELECT * FROM product_summary;

-- Test CREATE MATERIALIZED VIEW
CREATE MATERIALIZED VIEW customer_summary AS
SELECT country, COUNT(*) AS customer_count
FROM customers
GROUP BY country;

SELECT * FROM customer_summary;

REFRESH MATERIALIZED VIEW customer_summary;

-- Test FOR UPDATE/SHARE
SELECT * FROM products WHERE product_id = 1 FOR UPDATE;
SELECT * FROM products WHERE product_id = 1 FOR SHARE;

-- Test advisory lock
SELECT pg_advisory_lock(12345);
SELECT pg_advisory_unlock(12345);

-- Test generate_series
SELECT generate_series(1, 10);

-- Test window functions
SELECT
    product_name,
    price,
    RANK() OVER (ORDER BY price DESC) as price_rank
FROM products;

-- Test Common Table Expressions (CTEs)
WITH ExpensiveProducts AS (
    SELECT product_name, price
    FROM products
    WHERE price > 500
)
SELECT * FROM ExpensiveProducts;

-- Test UNION ALL
SELECT product_name FROM products WHERE category = 'Electronics'
UNION ALL
SELECT product_name FROM products WHERE category = 'Furniture';

-- Test INTERSECT
SELECT product_name FROM products WHERE price > 50
INTERSECT
SELECT product_name FROM products WHERE stock_quantity > 100;

-- Test EXCEPT
SELECT product_name FROM products WHERE category = 'Electronics'
EXCEPT
SELECT product_name FROM products WHERE price < 100;

-- Test LATERAL JOIN
SELECT c.customer_id, c.first_name, o.order_id
FROM customers c
LEFT JOIN LATERAL (
    SELECT order_id
    FROM orders
    WHERE customer_id = c.customer_id
    ORDER BY order_date DESC
    LIMIT 1
) o ON TRUE;

-- Test JSON functions
SELECT json_agg(products) FROM products;
SELECT json_object_agg(product_id, product_name) FROM products;

-- Test XML functions
SELECT XMLAGG(XMLELEMENT(NAME product, product_name)) FROM products;

-- Test regular expressions
SELECT * FROM products WHERE product_name ~* 'laptop|keyboard';

-- Test triggers
CREATE OR REPLACE FUNCTION update_order_total()
RETURNS TRIGGER AS $$
BEGIN
    NEW.total_amount := (SELECT price FROM products WHERE product_id = NEW.product_id) * NEW.quantity;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_order_total_trigger
BEFORE INSERT OR UPDATE ON orders
FOR EACH ROW
EXECUTE FUNCTION update_order_total();

INSERT INTO orders (customer_id, product_id, quantity) VALUES (1, 1, 1);

-- Alter the order manager role
ALTER ROLE order_manager WITH SUPERUSER;

-- Test prepared statements
PREPARE get_product_by_id (int) AS
SELECT * FROM products WHERE product_id = $1;

EXECUTE get_product_by_id(1);

DEALLOCATE get_product_by_id;

-- Test named type
CREATE TYPE inventory_stats AS (
  total_products int,
  average_price decimal
);

CREATE OR REPLACE FUNCTION get_inventory_stats()
RETURNS inventory_stats AS $$
DECLARE
  stats inventory_stats;
BEGIN
  SELECT count(*), avg(price) INTO stats.total_products, stats.average_price FROM products;
  RETURN stats;
END;
$$ LANGUAGE plpgsql;

SELECT get_inventory_stats();

DROP TYPE inventory_stats;

-- Test user-defined aggregates
CREATE AGGREGATE array_accum (anyelement)  (
    SFUNC = array_append,
    STYPE = anyarray,
    INITCOND = '{}'
);

SELECT array_accum(product_name) FROM products;

DROP AGGREGATE array_accum(anyelement);

-- Test user-defined operators
CREATE OPERATOR === (
    LEFTARG = integer,
    RIGHTARG = integer,
    PROCEDURE = int4eq
);

SELECT 1 === 1;

DROP OPERATOR === (integer, integer);

-- Test GENERATE STATISTICS
ALTER TABLE products ALTER COLUMN product_name SET STATISTICS 1000;

ANALYZE products;

-- Test SECURITY DEFINER function

CREATE OR REPLACE FUNCTION get_all_products()
RETURNS SETOF products AS $$
BEGIN
    RETURN QUERY SELECT * FROM products;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION get_all_products() TO sales_user;

SET SESSION AUTHORIZATION sales_user;

SELECT * FROM get_all_products();

RESET SESSION AUTHORIZATION;

-- Test autovacuum settings
ALTER TABLE products SET (autovacuum_vacuum_threshold = 50);

-- Test inheritence
CREATE TABLE discount_products (discount decimal) INHERITS (products);

INSERT INTO discount_products (product_name, price, stock_quantity, category, discount)
VALUES ('Discounted Laptop', 900.00, 10, 'Electronics', 0.1);

SELECT * FROM products;
SELECT * FROM discount_products;

-- Test LISTEN/NOTIFY
LISTEN product_update;

NOTIFY product_update, 'Product price updated';

UNLISTEN product_update;

DROP TABLE discount_products;

-- Clean up RLS
DROP POLICY IF EXISTS product_availability_policy ON products;
DROP POLICY IF EXISTS customer_country_policy ON customers;

ALTER TABLE products DISABLE ROW LEVEL SECURITY;
ALTER TABLE customers DISABLE ROW LEVEL SECURITY;
ALTER TABLE orders DISABLE ROW LEVEL SECURITY;