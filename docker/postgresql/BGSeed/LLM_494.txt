CREATE TABLE employees (
    id SERIAL PRIMARY KEY,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    email VARCHAR(100) UNIQUE,
    hire_date DATE,
    job_id INTEGER,
    salary DECIMAL(10, 2),
    department_id INTEGER
);

CREATE TABLE departments (
    id SERIAL PRIMARY KEY,
    name VARCHAR(50)
);

ALTER TABLE employees ADD CONSTRAINT fk_department
    FOREIGN KEY (department_id)
    REFERENCES departments (id)
    ON DELETE SET NULL;

INSERT INTO departments (name) VALUES
('Sales'),
('Marketing'),
('Engineering');

INSERT INTO employees (first_name, last_name, email, hire_date, job_id, salary, department_id) VALUES
('John', 'Doe', 'john.doe@example.com', '2022-01-01', 1, 60000.00, 1),
('Jane', 'Smith', 'jane.smith@example.com', '2022-02-15', 2, 75000.00, 2),
('Peter', 'Jones', 'peter.jones@example.com', '2022-03-10', 3, 90000.00, 3);

CREATE INDEX idx_employee_last_name ON employees (last_name);

-- Basic SELECT statements
SELECT * FROM employees;
SELECT first_name, last_name FROM employees WHERE department_id = 1;

-- JOIN operations
SELECT e.first_name, e.last_name, d.name AS department_name
FROM employees e
JOIN departments d ON e.department_id = d.id;

-- Aggregate functions and GROUP BY
SELECT department_id, AVG(salary) AS average_salary
FROM employees
GROUP BY department_id;

-- Subqueries
SELECT first_name, last_name
FROM employees
WHERE salary > (SELECT AVG(salary) FROM employees);

-- UPDATE and DELETE statements
UPDATE employees SET salary = salary * 1.1 WHERE department_id = 1;
DELETE FROM employees WHERE id = 3;

-- Window functions
SELECT
    first_name,
    last_name,
    salary,
    RANK() OVER (ORDER BY salary DESC) AS salary_rank
FROM employees;

-- Common Table Expressions (CTEs)
WITH HighSalaryEmployees AS (
    SELECT first_name, last_name, salary
    FROM employees
    WHERE salary > 70000
)
SELECT * FROM HighSalaryEmployees;

-- Using LIKE operator
SELECT * FROM employees WHERE first_name LIKE 'J%';

-- Using BETWEEN operator
SELECT * FROM employees WHERE hire_date BETWEEN '2022-01-01' AND '2022-02-28';

-- Using IN operator
SELECT * FROM employees WHERE department_id IN (1, 2);

-- Using CASE statement
SELECT
    first_name,
    last_name,
    CASE
        WHEN salary > 80000 THEN 'High'
        WHEN salary > 60000 THEN 'Medium'
        ELSE 'Low'
    END AS salary_level
FROM employees;

-- Using LIMIT and OFFSET
SELECT * FROM employees LIMIT 2 OFFSET 1;

-- Using ORDER BY
SELECT * FROM employees ORDER BY last_name ASC, first_name DESC;

-- Using DISTINCT
SELECT DISTINCT department_id FROM employees;

-- Using EXISTS operator
SELECT name FROM departments WHERE EXISTS (SELECT 1 FROM employees WHERE department_id = departments.id);

-- Using FULL OUTER JOIN
SELECT e.first_name, d.name
FROM employees e FULL OUTER JOIN departments d ON e.department_id = d.id;

-- Using INTERSECT and EXCEPT
SELECT department_id FROM employees INTERSECT SELECT id FROM departments;
SELECT department_id FROM employees EXCEPT SELECT id FROM departments;

-- Using table sample (PostgreSQL specific)
SELECT * FROM employees TABLESAMPLE SYSTEM (10);
SELECT * FROM employees TABLESAMPLE BERNOULLI (20);

-- Check constraint
ALTER TABLE employees ADD CONSTRAINT check_salary CHECK (salary >= 0);

-- Trigger Example
CREATE OR REPLACE FUNCTION check_employee_salary()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.salary < 0 THEN
    RAISE EXCEPTION 'Salary cannot be negative';
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER employee_salary_check
BEFORE INSERT OR UPDATE ON employees
FOR EACH ROW
EXECUTE FUNCTION check_employee_salary();

--Generated always column (PostgreSQL 12+)
ALTER TABLE employees ADD COLUMN full_name VARCHAR(100) GENERATED ALWAYS AS (first_name || ' ' || last_name) STORED;

-- Materialized view
CREATE MATERIALIZED VIEW employee_salaries AS
SELECT department_id, AVG(salary) AS avg_salary
FROM employees
GROUP BY department_id;

REFRESH MATERIALIZED VIEW employee_salaries;

-- Recursive CTE (example for hierarchical data, which is not present but demonstrates functionality)
WITH RECURSIVE EmployeeHierarchy AS (
    SELECT id, first_name, last_name, department_id, NULL::INTEGER AS manager_id, 0 AS level
    FROM employees
    WHERE id = 1 -- Assuming employee with ID 1 is the top level

    UNION ALL

    SELECT e.id, e.first_name, e.last_name, e.department_id, eh.id AS manager_id, eh.level + 1 AS level
    FROM employees e
    JOIN EmployeeHierarchy eh ON e.department_id = eh.department_id --Join condition adjusted to reflect reality of the data
    WHERE e.id <> eh.id -- avoid cycles
)
SELECT * FROM EmployeeHierarchy;