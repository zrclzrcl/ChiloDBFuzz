CREATE TABLE employees (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255),
    salary DECIMAL(10, 2),
    hire_date DATE,
    department VARCHAR(100)
);

CREATE TABLE departments (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    location VARCHAR(100)
);

-- Insert some sample data
INSERT INTO departments (name, location) VALUES
('Sales', 'New York'),
('Marketing', 'Los Angeles'),
('Engineering', 'San Francisco');

INSERT INTO employees (name, salary, hire_date, department) VALUES
('Alice Smith', 60000.00, '2022-01-15', 'Sales'),
('Bob Johnson', 75000.00, '2021-05-20', 'Marketing'),
('Charlie Brown', 90000.00, '2020-11-01', 'Engineering'),
('David Lee', 65000.00, '2023-03-10', 'Sales'),
('Eve Wilson', 80000.00, '2022-09-05', 'Marketing');

-- Basic SELECT queries
SELECT * FROM employees;
SELECT name, salary FROM employees WHERE department = 'Sales';
SELECT * FROM departments WHERE location = 'New York';

-- Aggregate functions
SELECT AVG(salary) FROM employees;
SELECT COUNT(*) FROM employees WHERE department = 'Engineering';
SELECT MAX(salary) FROM employees;
SELECT MIN(salary) FROM employees;
SELECT SUM(salary) FROM employees;
SELECT department, AVG(salary) FROM employees GROUP BY department;

-- JOIN queries
SELECT employees.name, departments.location
FROM employees
INNER JOIN departments ON employees.department = departments.name;

SELECT employees.name, departments.location
FROM employees
LEFT JOIN departments ON employees.department = departments.name;

SELECT employees.name, departments.location
FROM employees
RIGHT JOIN departments ON employees.department = departments.name;

-- Subqueries
SELECT * FROM employees WHERE salary > (SELECT AVG(salary) FROM employees);
SELECT name FROM departments WHERE id IN (SELECT id FROM departments WHERE location = 'New York');

-- ORDER BY and LIMIT
SELECT * FROM employees ORDER BY salary DESC LIMIT 3;
SELECT * FROM employees ORDER BY hire_date ASC LIMIT 2;

-- UPDATE and DELETE
UPDATE employees SET salary = salary * 1.1 WHERE department = 'Engineering';
DELETE FROM employees WHERE id = 5;

-- String functions
SELECT UPPER(name) FROM employees;
SELECT LOWER(department) FROM employees;
SELECT SUBSTRING(name, 1, 3) FROM employees;
SELECT LENGTH(name) FROM employees;

-- Date functions
SELECT EXTRACT(YEAR FROM hire_date) FROM employees;
SELECT AGE(hire_date) FROM employees;
SELECT NOW();
SELECT CURRENT_DATE;

-- Conditional expressions
SELECT name, salary, CASE
    WHEN salary > 80000 THEN 'High'
    WHEN salary > 65000 THEN 'Medium'
    ELSE 'Low'
    END AS salary_level
FROM employees;

-- Window functions
SELECT name, salary,
       RANK() OVER (ORDER BY salary DESC) as salary_rank
FROM employees;

-- Common Table Expressions (CTEs)
WITH HighSalaries AS (
    SELECT * FROM employees WHERE salary > 70000
)
SELECT * FROM HighSalaries ORDER BY salary DESC;

-- Create Index
CREATE INDEX idx_department ON employees (department);

-- Triggers (Example - Minimal, needs adaptation for specific needs)
CREATE OR REPLACE FUNCTION audit_employee_changes()
RETURNS TRIGGER AS $$
BEGIN
    RAISE NOTICE 'Employee data changed!';
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER employee_audit
AFTER INSERT OR UPDATE OR DELETE ON employees
FOR EACH ROW
EXECUTE FUNCTION audit_employee_changes();

-- Insert after Trigger creation
INSERT INTO employees (name, salary, hire_date, department) VALUES ('Test User', 50000, '2024-01-01', 'Sales');

-- Views
CREATE VIEW employee_salaries AS
SELECT name, salary FROM employees;

SELECT * FROM employee_salaries;

-- Materialized Views
CREATE MATERIALIZED VIEW materialized_employee_salaries AS
SELECT name, salary FROM employees;

SELECT * FROM materialized_employee_salaries;
REFRESH MATERIALIZED VIEW materialized_employee_salaries;

-- Generate UUID
SELECT gen_random_uuid();

-- Try some special data types
CREATE TABLE test_data_types (
  json_data JSONB,
  inet_address INET,
  cidr_block CIDR,
  mac_address MACADDR
);

INSERT INTO test_data_types (json_data, inet_address, cidr_block, mac_address) VALUES
('{"key": "value"}', '192.168.1.1', '192.168.1.0/24', '00:1A:2B:3C:4D:5E');

SELECT * FROM test_data_types;