CREATE DOMAIN domainvarchar AS VARCHAR(5);
CREATE DOMAIN positive_integer AS INTEGER CHECK (VALUE > 0);
CREATE DOMAIN email AS TEXT CHECK (VALUE ~* '^[A-Za-z0-9._+%-]+@[A-Za-z0-9.-]+[.][A-Za-z]+$');

CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) NOT NULL UNIQUE,
    email email,
    age positive_integer,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE UNLOGGED TABLE user_log (
    user_id INTEGER REFERENCES users(id),
    login_time TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    ip_address INET
);

CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

CREATE TABLE products (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    name VARCHAR(100) NOT NULL,
    description TEXT,
    price DECIMAL(10, 2) CHECK (price > 0),
    available BOOLEAN DEFAULT TRUE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE TYPE order_status AS ENUM ('pending', 'processing', 'shipped', 'delivered', 'cancelled');

CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id),
    order_date TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    total_amount DECIMAL(10, 2),
    status order_status DEFAULT 'pending'
);

CREATE TABLE order_items (
    order_id INTEGER REFERENCES orders(id),
    product_id UUID REFERENCES products(id),
    quantity INTEGER NOT NULL CHECK (quantity > 0),
    price DECIMAL(10, 2),
    PRIMARY KEY (order_id, product_id)
);

CREATE INDEX idx_orders_user_id ON orders (user_id);

INSERT INTO users (username, email, age) VALUES
('john_doe', 'john.doe@example.com', 30),
('jane_smith', 'jane.smith@example.org', 25),
('peter_jones', 'peter.jones@test.net', 40);

INSERT INTO products (name, description, price) VALUES
('Awesome T-Shirt', 'A really awesome t-shirt', 25.99),
('Cool Mug', 'A mug that keeps your drink cool', 12.50),
('Amazing Book', 'A book that will change your life', 19.99);

INSERT INTO orders (user_id, total_amount) VALUES
(1, 51.98),
(2, 12.50),
(3, 19.99);

INSERT INTO order_items (order_id, product_id, quantity, price)
SELECT 1, id, 2, 25.99 FROM products WHERE name = 'Awesome T-Shirt' UNION ALL
SELECT 2, id, 1, 12.50 FROM products WHERE name = 'Cool Mug' UNION ALL
SELECT 3, id, 1, 19.99 FROM products WHERE name = 'Amazing Book';

CREATE VIEW user_order_summary AS
SELECT
    u.username,
    COUNT(o.id) AS total_orders,
    SUM(o.total_amount) AS total_spent
FROM
    users u
LEFT JOIN
    orders o ON u.id = o.user_id
GROUP BY
    u.username
ORDER BY
    total_spent DESC;

CREATE OR REPLACE FUNCTION calculate_discount(price DECIMAL, discount_percentage DECIMAL)
RETURNS DECIMAL AS $$
BEGIN
    RETURN price * (1 - discount_percentage / 100);
END;
$$ LANGUAGE plpgsql;

SELECT calculate_discount(100, 10);

CREATE OR REPLACE FUNCTION get_user_age(user_id INTEGER)
RETURNS INTEGER AS $$
DECLARE
    user_age INTEGER;
BEGIN
    SELECT age INTO user_age FROM users WHERE id = user_id;
    RETURN user_age;
END;
$$ LANGUAGE plpgsql;

SELECT get_user_age(1);

SELECT * FROM users WHERE age BETWEEN 20 AND 35;
SELECT username, created_at::date FROM users;
SELECT name, price FROM products ORDER BY price DESC LIMIT 2;

UPDATE products SET price = price * 1.1 WHERE available = TRUE;

DELETE FROM products WHERE price > 100;

SELECT
    o.id AS order_id,
    u.username,
    p.name AS product_name,
    oi.quantity,
    oi.price
FROM
    orders o
JOIN
    users u ON o.user_id = u.id
JOIN
    order_items oi ON o.id = oi.order_id
JOIN
    products p ON oi.product_id = p.id;

SELECT
    status,
    COUNT(*)
FROM
    orders
GROUP BY
    status;

SELECT COALESCE(email, 'No Email') FROM users;
SELECT NULLIF(email, 'john.doe@example.com') FROM users;
SELECT CAST('2024-01-01' AS DATE);

SELECT
    CASE
        WHEN age < 18 THEN 'Minor'
        WHEN age BETWEEN 18 AND 65 THEN 'Adult'
        ELSE 'Senior'
    END AS age_group
FROM
    users;

WITH high_spending_users AS (
    SELECT user_id FROM orders GROUP BY user_id HAVING SUM(total_amount) > 50
)
SELECT u.username FROM users u JOIN high_spending_users h ON u.id = h.user_id;

SELECT generate_series(1, 10);

SELECT json_agg(users) FROM users;