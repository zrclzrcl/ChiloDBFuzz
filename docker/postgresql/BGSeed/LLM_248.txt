CREATE TABLE employees (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    salary DECIMAL(10, 2),
    department VARCHAR(50),
    hire_date DATE
);

CREATE INDEX idx_department ON employees (department);

INSERT INTO employees (name, salary, department, hire_date) VALUES
('Alice Smith', 60000.00, 'Sales', '2022-01-15'),
('Bob Johnson', 75000.00, 'Marketing', '2021-05-20'),
('Charlie Brown', 55000.00, 'Sales', '2023-03-10'),
('David Lee', 80000.00, 'Engineering', '2020-11-01'),
('Eve Wilson', 65000.00, 'Marketing', '2022-09-01');

SELECT * FROM employees WHERE department = 'Sales' ORDER BY salary DESC;

UPDATE employees SET salary = salary * 1.1 WHERE department = 'Marketing';

DELETE FROM employees WHERE hire_date < '2021-01-01';

SELECT department, AVG(salary) AS average_salary FROM employees GROUP BY department HAVING AVG(salary) > 60000;

CREATE VIEW high_earners AS
SELECT name, salary FROM employees WHERE salary > 70000;

SELECT * FROM high_earners;

ALTER TABLE employees ADD COLUMN bonus DECIMAL(10, 2) DEFAULT 0.00;

UPDATE employees SET bonus = salary * 0.05 WHERE department = 'Engineering';

SELECT name, salary, bonus, salary + bonus AS total_compensation FROM employees;

DROP VIEW high_earners;

CREATE OR REPLACE FUNCTION calculate_bonus(emp_id INTEGER)
RETURNS DECIMAL(10, 2) AS $$
BEGIN
    RETURN (SELECT salary * 0.1 FROM employees WHERE id = emp_id);
END;
$$ LANGUAGE plpgsql;

SELECT id, name, calculate_bonus(id) AS potential_bonus FROM employees;

DROP FUNCTION calculate_bonus(INTEGER);

CREATE TABLE audit_log (
    event_id SERIAL PRIMARY KEY,
    table_name VARCHAR(100),
    event_type VARCHAR(50),
    event_time TIMESTAMP,
    user_name VARCHAR(50)
);

CREATE OR REPLACE FUNCTION log_employee_changes()
RETURNS TRIGGER AS $$
BEGIN
    IF (TG_OP = 'UPDATE') THEN
        INSERT INTO audit_log (table_name, event_type, event_time, user_name)
        VALUES ('employees', 'UPDATE', NOW(), current_user);
        RETURN NEW;
    ELSIF (TG_OP = 'DELETE') THEN
        INSERT INTO audit_log (table_name, event_type, event_time, user_name)
        VALUES ('employees', 'DELETE', NOW(), current_user);
        RETURN OLD;
    ELSIF (TG_OP = 'INSERT') THEN
        INSERT INTO audit_log (table_name, event_type, event_time, user_name)
        VALUES ('employees', 'INSERT', NOW(), current_user);
        RETURN NEW;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER employee_changes
AFTER INSERT OR UPDATE OR DELETE ON employees
FOR EACH ROW
EXECUTE PROCEDURE log_employee_changes();

INSERT INTO employees (name, salary, department, hire_date) VALUES ('Frank White', 70000.00, 'Finance', '2023-07-01');

UPDATE employees SET salary = 82000.00 WHERE name = 'David Lee';

DELETE FROM employees WHERE name = 'Charlie Brown';

SELECT * FROM audit_log;

DROP TRIGGER employee_changes ON employees;
DROP FUNCTION log_employee_changes();
DROP TABLE audit_log;

-- Window function example
SELECT
    name,
    salary,
    department,
    RANK() OVER (PARTITION BY department ORDER BY salary DESC) as salary_rank
FROM
    employees;

-- Common Table Expression (CTE) example
WITH DepartmentAverages AS (
    SELECT department, AVG(salary) AS avg_salary
    FROM employees
    GROUP BY department
)
SELECT e.name, e.salary, d.avg_salary
FROM employees e
JOIN DepartmentAverages d ON e.department = d.department
WHERE e.salary > d.avg_salary;

-- Prepared statement example
PREPARE employee_salary_query (VARCHAR) AS
SELECT name, salary FROM employees WHERE department = $1;

EXECUTE employee_salary_query('Sales');
EXECUTE employee_salary_query('Engineering');

DEALLOCATE employee_salary_query;

-- Try some concurrency stuff
BEGIN;
LOCK TABLE employees IN EXCLUSIVE MODE;
SELECT * FROM employees;
COMMIT;

-- Checkpoint
CHECKPOINT;

-- vacuum and analyze
VACUUM VERBOSE employees;
ANALYZE VERBOSE employees;

DROP TABLE employees;