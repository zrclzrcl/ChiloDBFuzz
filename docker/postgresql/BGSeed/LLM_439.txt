CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    name VARCHAR(50) NOT NULL,
    price DECIMAL(10, 2) CHECK (price > 0),
    quantity INTEGER DEFAULT 0
);

CREATE INDEX idx_products_name ON products (name);

CREATE TYPE mood AS ENUM ('sad', 'ok', 'happy');

CREATE TABLE person (
    name TEXT,
    current_mood mood
);

INSERT INTO products (name, price, quantity) VALUES
('Laptop', 1200.00, 10),
('Mouse', 25.50, 50),
('Keyboard', 75.00, 30),
('Monitor', 300.00, 15);

INSERT INTO person (name, current_mood) VALUES
('Alice', 'happy'),
('Bob', 'sad'),
('Charlie', 'ok');

SELECT * FROM products WHERE price > 100 ORDER BY name;

UPDATE products SET quantity = quantity + 5 WHERE price < 50;

DELETE FROM products WHERE quantity = 0;

SELECT AVG(price) FROM products;

SELECT name, price FROM products WHERE price = (SELECT MAX(price) FROM products);

CREATE FUNCTION discount_price(price DECIMAL, discount DECIMAL)
RETURNS DECIMAL AS $$
BEGIN
    RETURN price * (1 - discount);
END;
$$ LANGUAGE plpgsql;

SELECT name, discount_price(price, 0.1) AS discounted_price FROM products;

CREATE VIEW high_priced_products AS
SELECT id, name, price, quantity FROM products WHERE price > 500;

SELECT * FROM high_priced_products;

CREATE MATERIALIZED VIEW materialized_products AS
SELECT id, name, price FROM products WHERE quantity > 5;

REFRESH MATERIALIZED VIEW materialized_products;

SELECT * FROM materialized_products;

CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    customer_id INTEGER,
    order_date DATE DEFAULT CURRENT_DATE
);

ALTER TABLE orders ADD COLUMN total_amount DECIMAL(10, 2);

CREATE TABLE order_items (
    item_id SERIAL PRIMARY KEY,
    order_id INTEGER REFERENCES orders(order_id),
    product_id INTEGER REFERENCES products(id),
    quantity INTEGER
);

INSERT INTO orders (customer_id, total_amount) VALUES (1, 1200.00);
INSERT INTO order_items (order_id, product_id, quantity) VALUES (1, 1, 1);

SELECT o.order_id, p.name, oi.quantity
FROM orders o
JOIN order_items oi ON o.order_id = oi.order_id
JOIN products p ON oi.product_id = p.id;

CREATE OR REPLACE FUNCTION calculate_total_amount(order_id INTEGER)
RETURNS DECIMAL AS $$
DECLARE
  total DECIMAL;
BEGIN
  SELECT SUM(p.price * oi.quantity) INTO total
  FROM order_items oi
  JOIN products p ON oi.product_id = p.id
  WHERE oi.order_id = order_id;

  RETURN total;
END;
$$ LANGUAGE plpgsql;

SELECT calculate_total_amount(1);

UPDATE orders SET total_amount = calculate_total_amount(order_id) WHERE order_id = 1;

CREATE RULE update_total AS ON INSERT TO order_items
DO UPDATE orders SET total_amount = calculate_total_amount(NEW.order_id) WHERE order_id = NEW.order_id;

CREATE SEQUENCE my_sequence START WITH 100 INCREMENT BY 5;
SELECT nextval('my_sequence');

SELECT setval('my_sequence', 200);
SELECT currval('my_sequence');
SELECT last_value FROM my_sequence;

-- Using window functions
SELECT name, price, RANK() OVER (ORDER BY price DESC) AS price_rank FROM products;

-- Using common table expressions (CTEs)
WITH RankedProducts AS (
    SELECT name, price, RANK() OVER (ORDER BY price DESC) AS price_rank FROM products
)
SELECT name, price FROM RankedProducts WHERE price_rank <= 2;

-- Table partitioning example
CREATE TABLE sales (
    sale_id SERIAL PRIMARY KEY,
    sale_date DATE NOT NULL,
    region TEXT NOT NULL,
    amount DECIMAL(10, 2) NOT NULL
) PARTITION BY RANGE (sale_date);

CREATE TABLE sales_y2023 PARTITION OF sales
    FOR VALUES FROM ('2023-01-01') TO ('2024-01-01');

INSERT INTO sales (sale_date, region, amount) VALUES
('2023-05-10', 'North', 500.00);

SELECT * FROM sales;

CREATE EXTENSION pg_trgm;

CREATE INDEX trgm_idx_products_name ON products USING GIN (name gin_trgm_ops);

SELECT name FROM products WHERE name % 'Keybord';

-- Foreign Data Wrapper Example
CREATE EXTENSION postgres_fdw;

CREATE SERVER remote_db
FOREIGN DATA WRAPPER postgres_fdw
OPTIONS (host 'localhost', port '5432', dbname 'another_db'); -- Replace with actual remote server details

CREATE USER MAPPING FOR CURRENT_USER
SERVER remote_db
OPTIONS (user 'remote_user', password 'remote_password'); -- Replace with actual remote user details and password

CREATE FOREIGN TABLE remote_table (
    id INTEGER,
    name TEXT
)
SERVER remote_db
OPTIONS (schema_name 'public', table_name 'some_table'); -- Replace with actual schema and table names

SELECT * FROM remote_table;

SELECT current_database();
SELECT current_schema();

SHOW server_version;
SHOW data_directory;

-- Advanced aggregation using GROUPING SETS, CUBE, and ROLLUP
SELECT region, EXTRACT(YEAR FROM sale_date), SUM(amount)
FROM sales
GROUP BY ROLLUP (region, EXTRACT(YEAR FROM sale_date));

-- Using LATERAL JOIN
CREATE TABLE departments (
    dept_id SERIAL PRIMARY KEY,
    dept_name TEXT
);

CREATE TABLE employees (
    emp_id SERIAL PRIMARY KEY,
    dept_id INTEGER REFERENCES departments(dept_id),
    emp_name TEXT,
    salary DECIMAL
);

INSERT INTO departments (dept_name) VALUES ('Sales'), ('Marketing');
INSERT INTO employees (dept_id, emp_name, salary) VALUES
(1, 'John Doe', 60000),
(1, 'Jane Smith', 70000),
(2, 'Peter Jones', 55000);

SELECT d.dept_name, e.emp_name, e.salary
FROM departments d
LEFT JOIN LATERAL (SELECT emp_name, salary FROM employees WHERE dept_id = d.dept_id ORDER BY salary DESC LIMIT 1) e ON TRUE;