SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

CREATE EXTENSION IF NOT EXISTS btree_gin;
CREATE EXTENSION IF NOT EXISTS btree_gist;
CREATE EXTENSION IF NOT EXISTS citext;
CREATE EXTENSION IF NOT EXISTS cube;
CREATE EXTENSION IF NOT EXISTS dblink;
CREATE EXTENSION IF NOT EXISTS dict_int;
CREATE EXTENSION IF NOT EXISTS dict_xsyn;
CREATE EXTENSION IF NOT EXISTS earthdistance WITH SCHEMA public;
CREATE EXTENSION IF NOT EXISTS fuzzystrmatch;
CREATE EXTENSION IF NOT EXISTS hstore;
CREATE EXTENSION IF NOT EXISTS intarray;
CREATE EXTENSION IF NOT EXISTS isn;
CREATE EXTENSION IF NOT EXISTS ltree;
CREATE EXTENSION IF NOT EXISTS pgcrypto;
CREATE EXTENSION IF NOT EXISTS pg_trgm;
CREATE EXTENSION IF NOT EXISTS plpgsql;
CREATE EXTENSION IF NOT EXISTS unaccent;
CREATE EXTENSION IF NOT EXISTS uuid-ossp;
CREATE EXTENSION IF NOT EXISTS xml2;

SET search_path = public, pg_catalog;

CREATE TABLE public.test_table (
    id integer NOT NULL,
    name text,
    value numeric(10,2),
    ts timestamp with time zone DEFAULT now()
);

ALTER TABLE public.test_table OWNER TO postgres;

CREATE SEQUENCE public.test_table_id_seq
    AS integer
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1;

ALTER TABLE public.test_table_id_seq OWNER TO postgres;

ALTER SEQUENCE public.test_table_id_seq OWNED BY public.test_table.id;

ALTER TABLE ONLY public.test_table ALTER COLUMN id SET DEFAULT nextval('public.test_table_id_seq'::regclass);

ALTER TABLE ONLY public.test_table
    ADD CONSTRAINT test_table_pkey PRIMARY KEY (id);

INSERT INTO public.test_table (name, value) VALUES ('Test 1', 123.45);
INSERT INTO public.test_table (name, value) VALUES ('Test 2', 678.90);
INSERT INTO public.test_table (name, value) VALUES ('Test 3', 987.65);

CREATE INDEX test_table_name_idx ON public.test_table USING gin (name gin_trgm_ops);

CREATE FUNCTION public.test_function(a integer, b integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
BEGIN
  RETURN a + b;
END;
$$;

ALTER FUNCTION public.test_function(a integer, b integer) OWNER TO postgres;

SELECT public.test_function(1, 2);

CREATE OR REPLACE VIEW public.test_view AS
 SELECT test_table.id,
    test_table.name,
    test_table.value
   FROM public.test_table
  WHERE (test_table.value > (100)::numeric);

ALTER TABLE public.test_view OWNER TO postgres;

SELECT * FROM public.test_view;

CREATE MATERIALIZED VIEW public.test_materialized_view AS
 SELECT test_table.id,
    test_table.name,
    test_table.value
   FROM public.test_table
  WHERE (test_table.value > (500)::numeric)
  WITH NO DATA;

ALTER TABLE public.test_materialized_view OWNER TO postgres;

REFRESH MATERIALIZED VIEW public.test_materialized_view;

SELECT * FROM public.test_materialized_view;

CREATE TYPE public.test_composite AS (
	field1 integer,
	field2 text
);

ALTER TYPE public.test_composite OWNER TO postgres;

CREATE TABLE public.test_composite_table (
    id integer NOT NULL,
    data public.test_composite
);

ALTER TABLE public.test_composite_table OWNER TO postgres;

INSERT INTO public.test_composite_table (id, data) VALUES (1, (1, 'Test')::public.test_composite);

SELECT * FROM public.test_composite_table;

CREATE DOMAIN public.us_postal_code AS TEXT
CHECK(VALUE ~ '^\d{5}(-\d{4})?$');

CREATE TABLE public.address (
  address_id SERIAL PRIMARY KEY,
  street VARCHAR(100) NOT NULL,
  city VARCHAR(50) NOT NULL,
  postal_code public.us_postal_code NOT NULL
);

INSERT INTO public.address (street, city, postal_code) VALUES ('123 Main St', 'Anytown', '12345');

SELECT * FROM public.address;

CREATE TABLE public.json_test (
  id SERIAL PRIMARY KEY,
  data JSONB
);

INSERT INTO public.json_test (data) VALUES ('{"name": "John Doe", "age": 30, "city": "New York"}');

SELECT * FROM public.json_test;

CREATE TABLE public.range_test (
  id SERIAL PRIMARY KEY,
  int4range int4range,
  tsrange tsrange
);

INSERT INTO public.range_test (int4range, tsrange) VALUES ('[10,20)', '[2023-01-01 00:00:00, 2023-01-02 00:00:00)');

SELECT * FROM public.range_test;

-- Add a trigger
CREATE OR REPLACE FUNCTION public.test_trigger_function()
RETURNS TRIGGER AS $$
BEGIN
  NEW.name := UPPER(NEW.name);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER test_table_before_insert
BEFORE INSERT ON public.test_table
FOR EACH ROW
EXECUTE FUNCTION public.test_trigger_function();

INSERT INTO public.test_table (name, value) VALUES ('test 4', 444.44);

SELECT * FROM public.test_table;

CREATE OR REPLACE PROCEDURE public.test_procedure(IN a integer, IN b integer, OUT sum integer)
LANGUAGE plpgsql
AS $$
BEGIN
  sum := a + b;
END;
$$;

CALL public.test_procedure(5, 3, NULL);

-- Add a rule
CREATE RULE test_table_insert AS ON INSERT TO public.test_view
DO INSTEAD NOTHING;

INSERT INTO public.test_view (id, name, value) VALUES (4, 'Test 4', 555.55);

SELECT * FROM public.test_table;

-- Partitioned Table
CREATE TABLE public.partitioned_table (
    logdate date NOT NULL,
    region text NOT NULL,
    details text,
    amount numeric
) PARTITION BY RANGE (logdate);

CREATE TABLE public.partitioned_table_y2023m01 PARTITION OF public.partitioned_table
    FOR VALUES FROM ('2023-01-01') TO ('2023-02-01');

INSERT INTO public.partitioned_table (logdate, region, details, amount) VALUES ('2023-01-15', 'North', 'Some Details', 100);
SELECT * FROM public.partitioned_table;

ANALYZE public.test_table;
CLUSTER public.test_table USING test_table_pkey;
REINDEX TABLE public.test_table;
VACUUM FULL public.test_table;