BEGIN;

-- Setting some configuration parameters
SET statement_timeout = '10s';
SET lock_timeout = '5s';
SET idle_in_transaction_session_timeout = '30s';
SET client_min_messages = 'warning';
SET search_path TO public;

-- Creating various tables with different data types and constraints
CREATE TABLE products (
    product_id SERIAL PRIMARY KEY,
    product_name VARCHAR(100) NOT NULL,
    description TEXT,
    price DECIMAL(10, 2) CHECK (price > 0),
    discount_rate NUMERIC(4,2),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT now()
);

CREATE TABLE categories (
    category_id SERIAL PRIMARY KEY,
    category_name VARCHAR(50) UNIQUE NOT NULL,
    parent_category_id INTEGER REFERENCES categories(category_id)
);

CREATE TABLE customers (
    customer_id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    first_name VARCHAR(50) NOT NULL,
    last_name VARCHAR(50) NOT NULL,
    email VARCHAR(100) UNIQUE,
    phone VARCHAR(20),
    address TEXT,
    registration_date DATE DEFAULT CURRENT_DATE
);

CREATE TABLE orders (
    order_id BIGSERIAL PRIMARY KEY,
    customer_id UUID REFERENCES customers(customer_id),
    order_date TIMESTAMP WITHOUT TIME ZONE DEFAULT now(),
    total_amount DECIMAL(12, 2)
);

CREATE TABLE order_items (
    order_item_id BIGSERIAL PRIMARY KEY,
    order_id BIGINT REFERENCES orders(order_id),
    product_id INTEGER REFERENCES products(product_id),
    quantity INTEGER NOT NULL CHECK (quantity > 0),
    unit_price DECIMAL(10, 2)
);

CREATE TABLE product_categories (
    product_id INTEGER REFERENCES products(product_id),
    category_id INTEGER REFERENCES categories(category_id),
    PRIMARY KEY (product_id, category_id)
);

-- Inserting data into tables
INSERT INTO categories (category_name) VALUES ('Electronics'), ('Books'), ('Clothing');
INSERT INTO categories (category_name, parent_category_id) VALUES ('Smartphones', 1), ('Fiction', 2);

INSERT INTO products (product_name, description, price) VALUES
    ('Laptop', 'High-performance laptop', 1200.00),
    ('Smartphone', 'Latest smartphone model', 900.00),
    ('Database Book', 'Introduction to databases', 45.00);

INSERT INTO product_categories (product_id, category_id) VALUES (1, 1), (2, 4), (3, 2), (3, 5);

INSERT INTO customers (first_name, last_name, email, phone) VALUES
    ('John', 'Doe', 'john.doe@example.com', '123-456-7890'),
    ('Jane', 'Smith', 'jane.smith@example.com', '987-654-3210');

INSERT INTO orders (customer_id, total_amount) VALUES
    ((SELECT customer_id FROM customers WHERE first_name = 'John'), 1245.00),
    ((SELECT customer_id FROM customers WHERE first_name = 'Jane'), 900.00);

INSERT INTO order_items (order_id, product_id, quantity, unit_price) VALUES
    (1, 1, 1, 1200.00),
    (1, 3, 1, 45.00),
    (2, 2, 1, 900.00);

-- Creating indexes
CREATE INDEX idx_customer_last_name ON customers (last_name);
CREATE INDEX idx_order_date ON orders (order_date);

-- Creating a view
CREATE VIEW customer_order_summary AS
SELECT c.first_name, c.last_name, o.order_id, o.order_date, o.total_amount
FROM customers c JOIN orders o ON c.customer_id = o.customer_id;

-- Creating a function
CREATE OR REPLACE FUNCTION calculate_discounted_price(price DECIMAL, discount_rate NUMERIC)
RETURNS DECIMAL AS $$
BEGIN
    RETURN price * (1 - discount_rate);
END;
$$ LANGUAGE plpgsql;

-- Using window functions
SELECT product_name, price,
       RANK() OVER (ORDER BY price DESC) as price_rank
FROM products;

-- Using common table expressions (CTEs)
WITH high_value_customers AS (
    SELECT customer_id FROM orders GROUP BY customer_id HAVING SUM(total_amount) > 1000
)
SELECT first_name, last_name FROM customers WHERE customer_id IN (SELECT customer_id FROM high_value_customers);

-- Using full text search
ALTER TABLE products ADD COLUMN search_vector tsvector;
UPDATE products SET search_vector = to_tsvector('english', product_name || ' ' || description);
CREATE INDEX idx_products_search ON products USING GIN (search_vector);
SELECT product_name FROM products WHERE search_vector @@ to_tsquery('english', 'laptop');

-- Using JSON functions
ALTER TABLE products ADD COLUMN product_details JSONB;
UPDATE products SET product_details = jsonb_build_object('manufacturer', 'Example Inc.', 'color', 'Silver') WHERE product_name = 'Laptop';
SELECT product_name, product_details ->> 'color' AS color FROM products WHERE product_name = 'Laptop';

-- Using aggregates and grouping
SELECT category_id, COUNT(*) FROM product_categories GROUP BY category_id;
SELECT customer_id, AVG(total_amount) FROM orders GROUP BY customer_id;

-- Using subqueries
SELECT product_name FROM products WHERE price > (SELECT AVG(price) FROM products);

-- Using array functions
CREATE TABLE tags (
    tag_id SERIAL PRIMARY KEY,
    tag_name VARCHAR(50) UNIQUE NOT NULL
);

CREATE TABLE product_tags (
    product_id INTEGER REFERENCES products(product_id),
    tag_id INTEGER REFERENCES tags(tag_id),
    PRIMARY KEY (product_id, tag_id)
);

INSERT INTO tags (tag_name) VALUES ('electronics'), ('new'), ('popular');
INSERT INTO product_tags (product_id, tag_id) VALUES (1, 1), (1, 2), (2, 1), (2, 3);

SELECT p.product_name, ARRAY_AGG(t.tag_name) AS tags
FROM products p
JOIN product_tags pt ON p.product_id = pt.product_id
JOIN tags t ON pt.tag_id = t.tag_id
GROUP BY p.product_name;

-- Creating user-defined types
CREATE TYPE address AS (
    street VARCHAR(100),
    city VARCHAR(50),
    zip_code VARCHAR(10)
);

ALTER TABLE customers ADD COLUMN shipping_address address;
UPDATE customers SET shipping_address = ROW('123 Main St', 'Anytown', '12345')::address WHERE first_name = 'John';
SELECT first_name, (shipping_address).city FROM customers WHERE first_name = 'John';

-- Using foreign data wrappers (requires setup, but including the syntax)
-- CREATE EXTENSION postgres_fdw;
-- CREATE SERVER foreign_server
--     FOREIGN DATA WRAPPER postgres_fdw
--     OPTIONS (host 'localhost', port '5432', dbname 'another_db');
-- CREATE USER MAPPING FOR CURRENT_USER
--     SERVER foreign_server
--     OPTIONS (user 'remote_user', password 'remote_password');
-- CREATE FOREIGN TABLE remote_table (
--     id INTEGER,
--     data TEXT
-- ) SERVER foreign_server
--     OPTIONS (schema_name 'public', table_name 'some_table');
-- SELECT * FROM remote_table;

-- Using triggers
CREATE OR REPLACE FUNCTION update_order_total()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE orders SET total_amount = (SELECT SUM(quantity * unit_price) FROM order_items WHERE order_id = NEW.order_id) WHERE order_id = NEW.order_id;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER order_items_insert AFTER INSERT ON order_items
FOR EACH ROW EXECUTE FUNCTION update_order_total();

INSERT INTO order_items (order_id, product_id, quantity, unit_price) VALUES (2, 3, 2, 45.00);

-- Using transactions and savepoints
SAVEPOINT my_savepoint;
UPDATE products SET price = 1300 WHERE product_name = 'Laptop';
ROLLBACK TO my_savepoint;

-- Vacuum and analyze
VACUUM VERBOSE ANALYZE products;
VACUUM VERBOSE ANALYZE customers;
VACUUM VERBOSE ANALYZE orders;
VACUUM VERBOSE ANALYZE order_items;
VACUUM VERBOSE ANALYZE categories;
VACUUM VERBOSE ANALYZE product_categories;

--Cleanup
DROP VIEW IF EXISTS customer_order_summary;
DROP TRIGGER IF EXISTS order_items_insert ON order_items;
DROP FUNCTION IF EXISTS update_order_total();
DROP FUNCTION IF EXISTS calculate_discounted_price(DECIMAL, NUMERIC);
DROP TABLE IF EXISTS product_tags;
DROP TABLE IF EXISTS tags;
DROP TABLE IF EXISTS product_categories;
DROP TABLE IF EXISTS order_items;
DROP TABLE IF EXISTS orders;
DROP TABLE IF EXISTS customers;
DROP TABLE IF EXISTS products;
DROP TABLE IF EXISTS categories;
DROP TYPE IF EXISTS address;

END;