CREATE TABLE employees (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    salary DECIMAL(10, 2),
    hire_date DATE,
    department VARCHAR(50)
);

INSERT INTO employees (name, salary, hire_date, department) VALUES
('Alice Smith', 60000.00, '2022-01-15', 'Sales'),
('Bob Johnson', 75000.00, '2021-05-20', 'Marketing'),
('Charlie Brown', 50000.00, '2023-03-10', 'Sales'),
('Diana Miller', 80000.00, '2020-11-01', 'Engineering'),
('Eve Wilson', 90000.00, '2019-09-25', 'Engineering');

CREATE INDEX idx_salary ON employees (salary);

SELECT * FROM employees WHERE salary > 70000.00;

UPDATE employees SET salary = salary * 1.10 WHERE department = 'Sales';

DELETE FROM employees WHERE hire_date < '2020-01-01';

SELECT department, AVG(salary) AS average_salary
FROM employees
GROUP BY department
ORDER BY average_salary DESC;

CREATE VIEW high_earners AS
SELECT id, name, salary
FROM employees
WHERE salary > 75000.00;

SELECT * FROM high_earners;

ALTER TABLE employees ADD COLUMN bonus DECIMAL(10, 2) DEFAULT 0.00;

UPDATE employees SET bonus = salary * 0.05 WHERE department = 'Engineering';

SELECT name, salary, bonus, salary + bonus AS total_compensation
FROM employees;

CREATE TABLE departments (
    department_id SERIAL PRIMARY KEY,
    department_name VARCHAR(50) UNIQUE
);

INSERT INTO departments (department_name) VALUES
('Sales'),
('Marketing'),
('Engineering');

ALTER TABLE employees ADD COLUMN department_id INTEGER REFERENCES departments(department_id);

UPDATE employees
SET department_id = (SELECT department_id FROM departments WHERE department_name = employees.department)
WHERE department IN (SELECT department_name FROM departments);

ALTER TABLE employees DROP COLUMN department;

SELECT e.name, e.salary, d.department_name
FROM employees e
JOIN departments d ON e.department_id = d.department_id;

CREATE FUNCTION calculate_bonus(emp_id INTEGER)
RETURNS DECIMAL(10, 2) AS $$
BEGIN
    RETURN (SELECT salary * 0.10 FROM employees WHERE id = emp_id);
END;
$$ LANGUAGE plpgsql;

SELECT name, salary, calculate_bonus(id) AS calculated_bonus FROM employees;

CREATE TABLE audit_log (
    log_id SERIAL PRIMARY KEY,
    table_name VARCHAR(100),
    record_id INTEGER,
    operation VARCHAR(10),
    timestamp TIMESTAMP WITHOUT TIME ZONE DEFAULT (NOW() AT TIME ZONE 'utc')
);

CREATE OR REPLACE FUNCTION log_employee_changes()
RETURNS TRIGGER AS $$
BEGIN
    IF (TG_OP = 'UPDATE') THEN
        INSERT INTO audit_log (table_name, record_id, operation)
        VALUES ('employees', OLD.id, 'UPDATE');
        RETURN NEW;
    ELSIF (TG_OP = 'DELETE') THEN
        INSERT INTO audit_log (table_name, record_id, operation)
        VALUES ('employees', OLD.id, 'DELETE');
        RETURN OLD;
    ELSIF (TG_OP = 'INSERT') THEN
        INSERT INTO audit_log (table_name, record_id, operation)
        VALUES ('employees', NEW.id, 'INSERT');
        RETURN NEW;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER employee_audit
AFTER INSERT OR UPDATE OR DELETE ON employees
FOR EACH ROW
EXECUTE FUNCTION log_employee_changes();

UPDATE employees SET salary = 82000 WHERE name = 'Diana Miller';
DELETE FROM employees WHERE name = 'Charlie Brown';
INSERT INTO employees (name, salary, hire_date, department_id) VALUES ('Frank White', 55000, '2023-04-01', (SELECT department_id FROM departments WHERE department_name = 'Sales'));

SELECT * FROM audit_log;

CREATE TABLE products (
  id SERIAL PRIMARY KEY,
  name VARCHAR(255) NOT NULL,
  price DECIMAL(10,2) NOT NULL
);

INSERT INTO products (name, price) VALUES
('Laptop', 1200.00),
('Mouse', 25.00),
('Keyboard', 75.00);

SELECT name, price FROM products ORDER BY price DESC;

-- Test for window functions
SELECT
    name,
    price,
    RANK() OVER (ORDER BY price DESC) AS price_rank
FROM
    products;

-- Test for common table expressions (CTEs)
WITH ExpensiveProducts AS (
    SELECT name, price
    FROM products
    WHERE price > 100
)
SELECT * FROM ExpensiveProducts;

-- Testing DISTINCT ON
SELECT DISTINCT ON (department_id) department_id, salary FROM employees ORDER BY department_id, salary DESC;

-- Testing LATERAL JOIN
CREATE TABLE employee_skills (
    employee_id INTEGER REFERENCES employees(id),
    skill VARCHAR(50)
);

INSERT INTO employee_skills (employee_id, skill) VALUES
(1, 'Sales'),
(1, 'Negotiation'),
(2, 'Marketing'),
(2, 'Advertising');

SELECT e.name, s.skill
FROM employees e
LEFT JOIN LATERAL (SELECT skill FROM employee_skills WHERE employee_id = e.id) s ON TRUE;

-- Testing JSON functionality
ALTER TABLE employees ADD COLUMN details JSONB;

UPDATE employees SET details = '{"age": 30, "city": "New York"}'::jsonb WHERE name = 'Alice Smith';

SELECT name, details ->> 'city' AS city FROM employees WHERE details IS NOT NULL;

-- Test materialized view
CREATE MATERIALIZED VIEW materialized_high_earners AS SELECT * FROM high_earners;
REFRESH MATERIALIZED VIEW materialized_high_earners;
SELECT * FROM materialized_high_earners;

-- Test array functions
ALTER TABLE employees ADD COLUMN languages TEXT[];
UPDATE employees SET languages = ARRAY['English', 'Spanish'] WHERE name = 'Alice Smith';
SELECT name, languages FROM employees WHERE 'Spanish' = ANY(languages);

-- Clean up (optional for fuzzing, but good practice)
DROP TRIGGER employee_audit ON employees;
DROP FUNCTION log_employee_changes();
DROP FUNCTION calculate_bonus(INTEGER);
DROP VIEW high_earners;
DROP MATERIALIZED VIEW materialized_high_earners;
DROP TABLE employee_skills;
DROP TABLE products;
DROP TABLE employees;
DROP TABLE departments;
DROP TABLE audit_log;