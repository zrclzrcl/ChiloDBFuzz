CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- Basic table creation and data manipulation
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(50) NOT NULL UNIQUE,
    email VARCHAR(100),
    created_at TIMESTAMPTZ DEFAULT NOW()
);

CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    price DECIMAL(10, 2) NOT NULL CHECK (price > 0),
    created_at TIMESTAMPTZ DEFAULT NOW()
);

INSERT INTO users (username, email) VALUES
    ('john_doe', 'john.doe@example.com'),
    ('jane_smith', 'jane.smith@example.com');

INSERT INTO products (name, description, price) VALUES
    ('Laptop', 'High-performance laptop', 1200.00),
    ('Mouse', 'Ergonomic wireless mouse', 25.00);

UPDATE users SET email = 'john.new@example.com' WHERE username = 'john_doe';

DELETE FROM products WHERE name = 'Mouse';

SELECT * FROM users;
SELECT * FROM products WHERE price > 100;

-- Transactions
BEGIN;
UPDATE users SET email = 'temp@example.com' WHERE username = 'jane_smith';
SELECT * FROM users WHERE username = 'jane_smith';
ROLLBACK;
SELECT * FROM users WHERE username = 'jane_smith';

BEGIN;
UPDATE products SET price = price * 1.1 WHERE name = 'Laptop';
SELECT * FROM products WHERE name = 'Laptop';
COMMIT;
SELECT * FROM products WHERE name = 'Laptop';

-- Joins and Subqueries
CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    user_id INTEGER REFERENCES users(id),
    order_date TIMESTAMPTZ DEFAULT NOW()
);

INSERT INTO orders (user_id) SELECT id FROM users WHERE username = 'john_doe';
INSERT INTO orders (user_id) SELECT id FROM users WHERE username = 'jane_smith';

CREATE TABLE order_items (
    id SERIAL PRIMARY KEY,
    order_id INTEGER REFERENCES orders(id),
    product_id INTEGER REFERENCES products(id),
    quantity INTEGER NOT NULL DEFAULT 1
);

INSERT INTO order_items (order_id, product_id, quantity) SELECT o.id, p.id, 2 FROM orders o, products p WHERE o.user_id = (SELECT id FROM users WHERE username = 'john_doe') AND p.name = 'Laptop';
INSERT INTO order_items (order_id, product_id, quantity) SELECT o.id, p.id, 1 FROM orders o, products p WHERE o.user_id = (SELECT id FROM users WHERE username = 'jane_smith') AND p.name = 'Laptop';

SELECT u.username, o.order_date FROM users u JOIN orders o ON u.id = o.user_id;
SELECT p.name FROM products WHERE id IN (SELECT product_id FROM order_items WHERE quantity > 1);

-- Functions and Procedures
CREATE OR REPLACE FUNCTION get_user_orders(user_name VARCHAR)
RETURNS TABLE (order_id INTEGER, order_date TIMESTAMPTZ) AS $$
BEGIN
    RETURN QUERY SELECT o.id, o.order_date FROM users u JOIN orders o ON u.id = o.user_id WHERE u.username = user_name;
END;
$$ LANGUAGE plpgsql;

SELECT * FROM get_user_orders('john_doe');

CREATE OR REPLACE PROCEDURE add_user(user_name VARCHAR, user_email VARCHAR)
LANGUAGE plpgsql
AS $$
BEGIN
    INSERT INTO users (username, email) VALUES (user_name, user_email);
    COMMIT;
END;
$$;

CALL add_user('new_user', 'new.user@example.com');
SELECT * FROM users WHERE username = 'new_user';

-- PostgreSQL-Specific Features
CREATE TYPE status_enum AS ENUM ('pending', 'processing', 'shipped', 'delivered');

ALTER TABLE orders ADD COLUMN status status_enum DEFAULT 'pending';
UPDATE orders SET status = 'shipped' WHERE id = 1;
SELECT id, status FROM orders;

CREATE TABLE data (
    id SERIAL PRIMARY KEY,
    payload JSONB
);

INSERT INTO data (payload) VALUES
    ('{"name": "item1", "value": 10}'),
    ('{"name": "item2", "value": 20, "details": {"color": "red"}}');

SELECT payload -> 'name' FROM data;
SELECT payload ->> 'name' FROM data;
SELECT payload #> '{details,color}' FROM data WHERE payload @> '{"details": {"color": "red"}}';

-- Generate series
SELECT generate_series(1, 10);
SELECT generate_series(NOW(), NOW() + interval '1 week', interval '1 day');

-- WITH ORDINALITY
SELECT * FROM unnest(ARRAY['a', 'b', 'c']) WITH ORDINALITY;

-- LATERAL
CREATE TABLE t1 (id int, arr int[]);
INSERT INTO t1 VALUES (1, ARRAY[1, 2, 3]), (2, ARRAY[4, 5]);
SELECT t1.id, x FROM t1, LATERAL unnest(t1.arr) AS x;

-- Window functions
SELECT
    username,
    created_at,
    ROW_NUMBER() OVER (ORDER BY created_at) as row_num
FROM
    users;

-- Partitioning
CREATE TABLE measurement (
    logdate timestamp without time zone NOT NULL,
    peaktemp int,
    unitsales int
) PARTITION BY RANGE (logdate);

CREATE TABLE measurement_y2006m02 PARTITION OF measurement
    FOR VALUES FROM ('2006-02-01') TO ('2006-03-01');

INSERT INTO measurement (logdate, peaktemp, unitsales) VALUES ('2006-02-01', 50, 100);
SELECT * from measurement;

-- More jsonb operations (after postgresql 12)
SELECT jsonb_path_exists('{"a": 1, "b": 2}', '$.a');
SELECT jsonb_path_match('{"a": 1, "b": 2}', '$.a == 1');

-- More advanced queries
SELECT u.username, COUNT(o.id) AS order_count
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
GROUP BY u.username
ORDER BY order_count DESC;

-- Trigger
CREATE OR REPLACE FUNCTION prevent_negative_price()
RETURNS TRIGGER AS $$
BEGIN
  IF NEW.price < 0 THEN
    RAISE EXCEPTION 'Price cannot be negative';
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER check_price_before_insert
BEFORE INSERT OR UPDATE ON products
FOR EACH ROW
EXECUTE FUNCTION prevent_negative_price();

INSERT INTO products (name, description, price) VALUES ('Invalid Product', 'Test', -10); -- This will raise an exception

-- Security Definer Function
CREATE OR REPLACE FUNCTION public.show_current_user()
RETURNS text
LANGUAGE sql
SECURITY DEFINER
AS $$
  SELECT current_user;
$$;

SELECT public.show_current_user();

-- Common Table Expression
WITH user_order_counts AS (
    SELECT u.username, COUNT(o.id) AS order_count
    FROM users u
    LEFT JOIN orders o ON u.id = o.user_id
    GROUP BY u.username
)
SELECT username, order_count
FROM user_order_counts
WHERE order_count > 0
ORDER BY order_count DESC;

-- Materialized View
CREATE MATERIALIZED VIEW user_order_summary AS
SELECT u.username, COUNT(o.id) AS total_orders
FROM users u
LEFT JOIN orders o ON u.id = o.user_id
GROUP BY u.username;

REFRESH MATERIALIZED VIEW user_order_summary;

SELECT * FROM user_order_summary;

-- Enum with collation
CREATE COLLATION german (locale = 'de_DE');
CREATE TYPE german_enum AS ENUM ('eins' COLLATE "german", 'zwei' COLLATE "german");
CREATE TABLE enum_table (val german_enum);
INSERT INTO enum_table VALUES ('eins');
SELECT * from enum_table;