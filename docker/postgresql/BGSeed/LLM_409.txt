CREATE TABLE test_table (
  id SERIAL PRIMARY KEY,
  name VARCHAR(50) NOT NULL,
  age INTEGER,
  email VARCHAR(100) UNIQUE
);

INSERT INTO test_table (name, age, email) VALUES
('Alice', 30, 'alice@example.com'),
('Bob', 25, 'bob@example.com'),
('Charlie', 40, 'charlie@example.com');

SELECT * FROM test_table WHERE age > 28;

UPDATE test_table SET age = 31 WHERE name = 'Alice';

DELETE FROM test_table WHERE name = 'Charlie';

SELECT COUNT(*) FROM test_table;

SELECT AVG(age) FROM test_table;

SELECT MAX(age) FROM test_table;

SELECT MIN(age) FROM test_table;

SELECT SUM(age) FROM test_table;

SELECT name, age FROM test_table ORDER BY age DESC;

SELECT name, age FROM test_table ORDER BY name ASC;

SELECT name, age FROM test_table LIMIT 2;

SELECT name, age FROM test_table OFFSET 1;

SELECT name, age FROM test_table LIMIT 2 OFFSET 1;

CREATE INDEX idx_name ON test_table (name);

DROP INDEX idx_name;

ALTER TABLE test_table ADD COLUMN address VARCHAR(200);

ALTER TABLE test_table DROP COLUMN address;

SELECT version();

SHOW server_version;

SHOW data_directory;

CREATE VIEW adult_users AS
SELECT id, name, age, email
FROM test_table
WHERE age >= 18;

SELECT * FROM adult_users;

DROP VIEW adult_users;

SELECT pg_backend_pid();

SELECT current_database();

SELECT current_user;

SELECT now();

SELECT current_timestamp;

SELECT inet_client_addr();

SELECT inet_server_addr();

SELECT session_user;

SELECT CAST('2024-01-01' AS DATE);

SELECT '2024-01-01'::DATE;

SELECT EXTRACT(YEAR FROM now());

SELECT substring('foobar' from 4 for 2);

SELECT length('foobar');

SELECT upper('foobar');

SELECT lower('FOOBAR');

SELECT md5('foobar');

SELECT encode('foobar', 'hex');

SELECT decode('666f6f626172', 'hex');

SELECT coalesce(NULL, 'foobar', 'baz');

SELECT NULLIF('foobar', 'foobar');

SELECT greatest(1, 2, 3);

SELECT least(1, 2, 3);

SELECT random();

SELECT generate_series(1, 5);

SELECT setseed(0.5);

CREATE TEMPORARY TABLE temp_table (
  id INTEGER
);

INSERT INTO temp_table VALUES (1), (2), (3);

SELECT * FROM temp_table;

DROP TABLE temp_table;

CREATE TYPE mood AS ENUM ('sad', 'ok', 'happy');

CREATE TABLE person (
    name text,
    current_mood mood
);

INSERT INTO person (name, current_mood) VALUES ('John', 'happy');
INSERT INTO person (name, current_mood) VALUES ('Mary', 'sad');

SELECT * FROM person;

DROP TABLE person;
DROP TYPE mood;

-- Check constraints

CREATE TABLE products (
    product_no integer,
    name text,
    price numeric CHECK (price > 0)
);

INSERT INTO products (product_no, name, price) VALUES (1, 'Toy', 10.00);
-- This one should fail
-- INSERT INTO products (product_no, name, price) VALUES (2, 'Toy', -10.00);

DROP TABLE products;

-- Foreign Key Constraints

CREATE TABLE cities (
    city_id integer PRIMARY KEY,
    city_name text
);

CREATE TABLE weather (
    city_id integer REFERENCES cities (city_id),
    temp_lo integer,
    temp_hi integer,
    prcp real,
    date date
);

INSERT INTO cities (city_id, city_name) VALUES (1, 'San Francisco');
INSERT INTO weather (city_id, temp_lo, temp_hi, prcp, date) VALUES (1, 43, 57, 0.0, '2024-01-01');

DROP TABLE weather;
DROP TABLE cities;

-- Unique constraints

CREATE TABLE example (
    a integer UNIQUE,
    b text
);

INSERT INTO example (a, b) VALUES (1, 'Test');

DROP TABLE example;

-- Exclusion constraints (requires btree_gist extension)

CREATE EXTENSION btree_gist;

CREATE TABLE reservations (
    during tsrange,
    EXCLUDE USING gist (during WITH &&)
);

INSERT INTO reservations (during) VALUES ('[2024-01-01,2024-01-02)'::tsrange);
-- This should fail because it overlaps
-- INSERT INTO reservations (during) VALUES ('[2024-01-01,2024-01-03)'::tsrange);

DROP TABLE reservations;
DROP EXTENSION btree_gist;

-- Window functions

CREATE TABLE salaries (
    depname varchar(10),
    empno integer,
    salary integer
);

INSERT INTO salaries (depname, empno, salary) VALUES ('toy', 1, 5000);
INSERT INTO salaries (depname, empno, salary) VALUES ('toy', 2, 4800);
INSERT INTO salaries (depname, empno, salary) VALUES ('toy', 3, 5200);
INSERT INTO salaries (depname, empno, salary) VALUES ('dev', 7, 6000);
INSERT INTO salaries (depname, empno, salary) VALUES ('dev', 9, 4500);
INSERT INTO salaries (depname, empno, salary) VALUES ('dev', 8, 6000);
INSERT INTO salaries (depname, empno, salary) VALUES ('sales', 3, 4800);
INSERT INTO salaries (depname, empno, salary) VALUES ('sales', 5, 4800);
INSERT INTO salaries (depname, empno, salary) VALUES ('sales', 4, 4900);

SELECT
    depname,
    empno,
    salary,
    avg(salary) OVER (PARTITION BY depname)
FROM salaries;

DROP TABLE salaries;

-- Common Table Expressions (CTEs)

WITH RegionalSales AS (
    SELECT region, SUM(amount) AS total_sales
    FROM sales
    GROUP BY region
)
SELECT region, total_sales
FROM RegionalSales
WHERE total_sales > (SELECT AVG(total_sales) FROM RegionalSales);

-- Materialized views

CREATE MATERIALIZED VIEW my_materialized_view AS
SELECT id, name FROM test_table WHERE age > 25;

REFRESH MATERIALIZED VIEW my_materialized_view;

DROP MATERIALIZED VIEW my_materialized_view;

-- Sequences

CREATE SEQUENCE serial_number START 101;

SELECT nextval('serial_number');

DROP SEQUENCE serial_number;

-- Checkpoint command
CHECKPOINT;

-- Vacuum command
VACUUM test_table;

-- Explain command
EXPLAIN SELECT * FROM test_table WHERE age > 30;

-- Create function
CREATE OR REPLACE FUNCTION add_integer(a INTEGER, b INTEGER)
RETURNS INTEGER AS $$
BEGIN
  RETURN a + b;
END;
$$ LANGUAGE plpgsql;

SELECT add_integer(5, 3);

DROP FUNCTION add_integer(INTEGER, INTEGER);

-- Row level security
CREATE TABLE accounts (
    manager text,
    company text,
    contact_email text
);

CREATE POLICY account_managers ON accounts TO managers
    USING (manager = current_user);

DROP POLICY account_managers ON accounts;
DROP TABLE accounts;

-- Prepared statements
PREPARE my_query (int) AS
SELECT * FROM test_table WHERE id = $1;

EXECUTE my_query(1);

DEALLOCATE my_query;

-- Recursive queries
CREATE TABLE employee (
    id int PRIMARY KEY,
    name varchar(50),
    manager_id int REFERENCES employee(id)
);

INSERT INTO employee (id, name, manager_id) VALUES
(1, 'John', NULL),
(2, 'Alice', 1),
(3, 'Bob', 1),
(4, 'Charlie', 2);

WITH RECURSIVE employee_hierarchy AS (
    SELECT id, name, manager_id, 0 AS level
    FROM employee
    WHERE manager_id IS NULL

    UNION ALL

    SELECT e.id, e.name, e.manager_id, eh.level + 1
    FROM employee e
    JOIN employee_hierarchy eh ON e.manager_id = eh.id
)
SELECT * FROM employee_hierarchy;

DROP TABLE employee;

-- Insert on conflict

CREATE TABLE t1 (
    id INT PRIMARY KEY,
    val TEXT
);

INSERT INTO t1 VALUES (1, 'foo')
ON CONFLICT (id) DO NOTHING;

DROP TABLE t1;