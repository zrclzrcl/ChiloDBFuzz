-- Initial seed for PostgreSQL 18 RC1

-- Create a simple table
CREATE TABLE employees (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    department VARCHAR(50),
    salary DECIMAL(10, 2)
);

-- Insert some data
INSERT INTO employees (name, department, salary) VALUES
    ('Alice Smith', 'Sales', 60000.00),
    ('Bob Johnson', 'Marketing', 75000.00),
    ('Charlie Brown', 'Sales', 62000.00),
    ('David Lee', 'Engineering', 90000.00),
    ('Eve Wilson', 'Marketing', 78000.00);

-- Select all employees
SELECT * FROM employees;

-- Select employees in the Sales department
SELECT name, salary FROM employees WHERE department = 'Sales';

-- Update salary for an employee
UPDATE employees SET salary = 65000.00 WHERE name = 'Alice Smith';

-- Delete an employee
DELETE FROM employees WHERE name = 'Charlie Brown';

-- Aggregate functions
SELECT department, AVG(salary) AS average_salary FROM employees GROUP BY department;

-- Order by salary
SELECT name, salary FROM employees ORDER BY salary DESC;

-- Limit and offset
SELECT name, salary FROM employees ORDER BY salary ASC LIMIT 2 OFFSET 1;

-- Create a second table with a foreign key
CREATE TABLE departments (
    id SERIAL PRIMARY KEY,
    name VARCHAR(50) UNIQUE NOT NULL,
    location VARCHAR(100)
);

INSERT INTO departments (name, location) VALUES
    ('Sales', 'New York'),
    ('Marketing', 'London'),
    ('Engineering', 'San Francisco');

ALTER TABLE employees ADD COLUMN department_id INTEGER REFERENCES departments(id);

UPDATE employees SET department_id = (SELECT id FROM departments WHERE name = employees.department);

ALTER TABLE employees DROP COLUMN department;

-- Join the tables
SELECT e.name, d.name AS department_name, d.location
FROM employees e
JOIN departments d ON e.department_id = d.id;

-- Subquery
SELECT name, salary FROM employees WHERE department_id IN (SELECT id FROM departments WHERE location = 'London');

-- Common Table Expression (CTE)
WITH high_earners AS (
    SELECT id, name, salary FROM employees WHERE salary > 70000
)
SELECT he.name, d.name AS department_name
FROM high_earners he
JOIN departments d ON he.department_id = d.id;

-- Window function
SELECT
    name,
    salary,
    RANK() OVER (ORDER BY salary DESC) AS salary_rank
FROM employees;

-- Case statement
SELECT
    name,
    salary,
    CASE
        WHEN salary > 80000 THEN 'High'
        WHEN salary > 60000 THEN 'Medium'
        ELSE 'Low'
    END AS salary_level
FROM employees;

-- jsonb example
CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100),
    details jsonb
);

INSERT INTO products (name, details) VALUES
    ('Laptop', '{"brand": "Dell", "model": "XPS 13", "price": 1200}'),
    ('Keyboard', '{"brand": "Logitech", "model": "MX Keys", "price": 100}');

SELECT name, details -> 'price' FROM products;

-- Generated always as
CREATE TABLE measurements (
  height numeric,
  width numeric,
  area numeric GENERATED ALWAYS AS (height * width) STORED
);

INSERT INTO measurements(height, width) VALUES (2,3);

SELECT * from measurements;

--Create collation
CREATE COLLATION german (locale = 'de_DE');

-- Create domain
CREATE DOMAIN us_postal_code AS TEXT
CHECK(VALUE ~ '^\d{5}$' OR VALUE ~ '^\d{5}-\d{4}$');

CREATE TABLE addresses (
  id SERIAL PRIMARY KEY,
  postal_code us_postal_code
);

INSERT INTO addresses (postal_code) VALUES ('12345');
INSERT INTO addresses (postal_code) VALUES ('12345-6789');

-- Create Enum
CREATE TYPE mood AS ENUM ('sad', 'ok', 'happy');
CREATE TABLE person (
    name text,
    current_mood mood
);
INSERT INTO person VALUES ('Moe', 'happy');
SELECT * FROM person;

-- Vacuum table
VACUUM employees;

-- ANALYZE table
ANALYZE employees;

-- Reset the table
TRUNCATE TABLE employees RESTART IDENTITY;