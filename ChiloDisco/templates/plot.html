<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ChiloDisco Â· æ•°æ®å¤§å±</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&family=Orbitron:wght@500;600&family=Noto+Sans+SC:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/static/css/styles.css" />
  <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>
  <script src="/static/js/toast.js"></script>
</head>
<body>
  <canvas id="globalParticles"></canvas>
  <div id="app" class="layout">
    <aside class="sidenav">
      <div class="nav-brand">
        <span class="logo">âš¡</span>
        <span class="title">ChiloDisco</span>
      </div>
      <nav class="nav-links">
        <a href="/">æ—¥å¿—ç›‘æ§</a>
        <a class="active" href="/plot">æ•°æ®å¤§å±</a>
        <a href="/bitmap">Bitmap çƒ­åŠ›å›¾</a>
        <a href="/downloads">ç»“æœä¸‹è½½</a>
        <a href="/settings">ç³»ç»Ÿè®¾ç½®</a>
      </nav>
    </aside>

    <div class="content">
      <header class="app-header">
        <div class="brand">
          <span class="subtitle">AFL++ Â· æ•°æ®å¯è§†åŒ–å¤§å±</span>
        </div>
        <div class="controls" style="gap:12px">
          <label>åˆ·æ–°é¢‘ç‡</label>
          <select id="intervalSel">
            <option value="100" selected>0.1s</option>
            <option value="200">0.2s</option>
            <option value="500">0.5s</option>
            <option value="1000">1s</option>
            <option value="2000">2s</option>
            <option value="5000">5s</option>
          </select>
          <div class="export-menu">
            <button id="exportBtn" class="btn">ğŸ“¥ å¯¼å‡º</button>
            <div class="export-dropdown" id="exportDropdown">
              <button onclick="exportChart()">ğŸ“Š å¯¼å‡ºå›¾è¡¨ (PNG)</button>
              <button onclick="exportData()">ğŸ“„ å¯¼å‡ºæ•°æ® (CSV)</button>
              <button onclick="exportAll()">ğŸ“¦ å…¨éƒ¨å¯¼å‡º</button>
            </div>
          </div>
          <span id="dataPath" style="color:var(--text-muted); font-size:13px"></span>
        </div>
      </header>

      <main id="mainGrid" class="grid" style="grid-template-columns: 1fr 1fr; grid-template-rows: 1.2fr 0.9fr 0.9fr 1fr; height: calc(100vh - 140px); min-height: 0; overflow: visible; padding: 20px;">
        <!-- ç¬¬1è¡Œï¼šæŠ˜çº¿å›¾ï¼Œæ¨ªè·¨ä¸¤åˆ— -->
        <section class="card" style="grid-column: 1 / span 2;">
          <header class="card-header">
            <div class="name">å®æ—¶æ•°æ®æ›²çº¿</div>
            <div class="file" id="plot-meta"></div>
            <button class="btn-icon" onclick="exportChart()" title="å¯¼å‡ºå›¾è¡¨ä¸º PNG">ğŸ“Š</button>
          </header>
          <div id="lineChart" style="width:100%; height:100%;"></div>
        </section>

        <!-- ç¬¬2è¡Œï¼šä¸¤ä¸ªä»ªè¡¨ç›˜ï¼Œå„å ä¸€åŠ -->
        <section class="card">
          <header class="card-header" style="min-height: 40px; padding: 6px 12px;"><div class="name">Pending Total</div></header>
          <div id="gauge1" style="width:100%; height:100%;"></div>
        </section>
        <section class="card">
          <header class="card-header" style="min-height: 40px; padding: 6px 12px;"><div class="name">Pending Favs</div></header>
          <div id="gauge2" style="width:100%; height:100%;"></div>
        </section>

        <!-- ç¬¬3è¡Œï¼šå·¦è¾¹ Execs/sec ä»ªè¡¨ç›˜ï¼›å³è¾¹ æœ€æ–°æŒ‡æ ‡ ç‹¬ç«‹å¡ç‰‡ -->
        <section class="card">
          <header class="card-header" style="min-height: 40px; padding: 6px 12px;"><div class="name">Execs / Sec</div></header>
          <div id="gauge3" style="width:100%; height:100%;"></div>
        </section>
        <section class="card">
          <header class="card-header"><div class="name">å®æ—¶æŒ‡æ ‡</div></header>
          <div class="stats-compact" style="display:grid; grid-template-columns: repeat(2, 1fr); gap: 12px; height: calc(100% - 56px); padding: 16px;">
            <div class="stat-compact" id="s_cycles">
              <div class="stat-icon">ğŸ”„</div>
              <div class="stat-content">
                <div class="stat-label">Cycles</div>
                <div class="stat-value">â€”</div>
              </div>
            </div>
            <div class="stat-compact" id="s_cur_item">
              <div class="stat-icon">ğŸ“Œ</div>
              <div class="stat-content">
                <div class="stat-label">Current</div>
                <div class="stat-value">â€”</div>
              </div>
            </div>
            <div class="stat-compact" id="s_saved_crashes">
              <div class="stat-icon">ğŸ’¥</div>
              <div class="stat-content">
                <div class="stat-label">Crashes</div>
                <div class="stat-value stat-danger">â€”</div>
              </div>
            </div>
            <div class="stat-compact" id="s_max_depth">
              <div class="stat-icon">ğŸ“</div>
              <div class="stat-content">
                <div class="stat-label">Depth</div>
                <div class="stat-value">â€”</div>
              </div>
            </div>
            <div class="stat-compact" id="s_total_execs" style="grid-column: 1 / -1;">
              <div class="stat-icon">ğŸ¯</div>
              <div class="stat-content">
                <div class="stat-label">Total Execs</div>
                <div class="stat-value">â€”</div>
              </div>
            </div>
          </div>
        </section>

        <!-- ç¬¬4è¡Œï¼š.cur_input å±•ç¤ºå¤§å¡ç‰‡ï¼Œæ¨ªè·¨ä¸¤åˆ— -->
        <section class="card" id="curCard" style="grid-column: 1 / span 2; transition: box-shadow .6s ease, border-color .6s ease;">
          <header class="card-header">
            <div class="name">å½“å‰è¾“å…¥æ ·æœ¬</div>
            <div class="file" id="curMeta">ï¼ˆç­‰å¾…æ•°æ®â€¦ï¼‰</div>
            <div class="meta">
              <span class="mtime" id="curTimer" title="å½“å‰å†…å®¹æŒç»­æ—¶é—´">â€”</span>
            </div>
          </header>
          <div id="curContent" style="height: calc(100% - 56px); padding: 16px; overflow-x: hidden; overflow-y: auto; white-space: pre-wrap; word-break: break-word; overflow-wrap: anywhere; hyphens: auto; line-height: 1.5; font-size: 13px; column-gap: 24px; column-fill: auto; -webkit-column-fill: auto; column-rule: 1px solid var(--border-light); background: var(--bg-secondary);">
            ï¼ˆç©ºï¼‰
          </div>
        </section>
      </main>

      <footer class="app-footer">
        <div class="legend">
          <span>æ•°æ®è¯´æ˜ï¼š</span>
          <span>æŠ˜çº¿å›¾ï¼šmap_size, edges_found, corpus_count | ä»ªè¡¨ç›˜ï¼špending_total, pending_favs, execs_per_sec</span>
        </div>
        <div class="copyright">Â© 2025 ChiloDisco</div>
      </footer>
    </div>
  </div>

  <script>
    // éœ“è™¹èµ›åšæœ‹å…‹ ECharts ä¸»é¢˜
    echarts.registerTheme('chiloNeon', {
      color: ['#00f0ff','#8b5cf6','#ff006e','#00ff9f','#ffed4e'],
      backgroundColor: 'transparent',
      textStyle: { fontFamily: 'JetBrains Mono, Noto Sans SC, monospace', color: '#e0e7ff' },
      grid: { containLabel: true },
      tooltip: { 
        backgroundColor: 'rgba(19,24,36,0.95)', 
        borderColor: 'rgba(0,240,255,0.5)',
        borderWidth: 2,
        textStyle:{ color: '#e0e7ff' },
        extraCssText: 'box-shadow: 0 0 20px rgba(0,240,255,0.4); backdrop-filter: blur(10px);'
      },
      categoryAxis: {
        axisLine: { lineStyle: { color: 'rgba(0,240,255,0.3)' }},
        axisLabel: { color: '#6b7280' },
        splitLine: { show: false }
      },
      valueAxis: {
        axisLine: { lineStyle: { color: 'rgba(0,240,255,0.3)' }},
        axisLabel: { color: '#6b7280' },
        splitLine: { lineStyle: { color: 'rgba(139,92,246,0.15)' }}
      },
      legend: { textStyle: { color: '#e0e7ff' } }
    });

    const intervalSel = document.getElementById('intervalSel');
    const dataPathEl = document.getElementById('dataPath');
    const metaEl = document.getElementById('plot-meta');
    const mainGrid = document.getElementById('mainGrid');

    let timer = null;
    
    // ä» localStorage æ¢å¤ç”¨æˆ·çš„åˆ·æ–°é¢‘ç‡è®¾ç½®
    const savedInterval = localStorage.getItem('cd_plot_interval');
    if (savedInterval) {
      intervalSel.value = savedInterval;
    }
    let interval = parseInt(intervalSel.value, 10) || 100;

    // ä½¿ç”¨éœ“è™¹èµ›åšæœ‹å…‹ä¸»é¢˜åˆå§‹åŒ–
    const lineChart = echarts.init(document.getElementById('lineChart'), 'chiloNeon');
    const gauge1 = echarts.init(document.getElementById('gauge1'), 'chiloNeon');
    const gauge2 = echarts.init(document.getElementById('gauge2'), 'chiloNeon');
    const gauge3 = echarts.init(document.getElementById('gauge3'), 'chiloNeon');

    // æ¨ªç«–å±è‡ªé€‚åº”å¸ƒå±€
    const mqLandscape = window.matchMedia('(orientation: landscape)');

    // å·¥å…·ï¼šæ‰¾åˆ°æŸä¸ªå­å…ƒç´ æ‰€åœ¨çš„ sectionï¼ˆå¡ç‰‡ï¼‰
    function cardOf(childId){
      const el = document.getElementById(childId);
      return el ? el.closest('section') : null;
    }
    const lineCard  = cardOf('lineChart');
    const g1Card    = cardOf('gauge1');
    const g2Card    = cardOf('gauge2');
    const g3Card    = cardOf('gauge3');
    const curCardEl = document.getElementById('curCard');
    const statsCard = (function(){
      const s = document.getElementById('s_cycles');
      return s ? s.closest('section') : null;
    })();

    function applyLayout(){
      if (!mainGrid) return;
      const w = window.innerWidth || document.documentElement.clientWidth || 0;
      const h = window.innerHeight || document.documentElement.clientHeight || 0;
      const aspect = h > 0 ? (w / h) : 1.6;
      const headerFooter = 140; // ä¸æ¨¡æ¿ä¸€è‡´çš„å¤´å°¾é«˜åº¦ä¼°ç®—
      mainGrid.style.height = `calc(100vh - ${headerFooter}px)`;

      if (mqLandscape.matches){
        // æ¨ªå±ï¼šç¬¬1è¡Œæ›´é«˜å¹¶æ”¾ç½®"æŠ˜çº¿å›¾ + æœ€æ–°æŒ‡æ ‡"ï¼›ç¬¬2è¡Œä¸‰ä»ªè¡¨ç›˜æ›´ç´§å‡‘ï¼›ç¬¬3è¡Œ .cur_input å æ»¡
        mainGrid.style.gridTemplateColumns = '1fr 1fr 1fr';
        if (aspect >= 2.0){
          // è¶…å®½æ¨ªå±ï¼šæ˜¾è‘—æŠ¬é«˜ç¬¬1è¡Œï¼Œé€‚å½“å‹ç¼©ä»ªè¡¨ç›˜è¡Œ
          mainGrid.style.gridTemplateRows = '2.6fr 1.3fr 1.9fr';
        } else if (aspect >= 1.6){
          // æ ‡å‡†æ¨ªå±
          mainGrid.style.gridTemplateRows = '2.4fr 1.3fr 1.7fr';
        } else {
          // è¿‡æ¸¡æ¨ªå±
          mainGrid.style.gridTemplateRows = '2.2fr 1.2fr 1.6fr';
        }
        // ç¬¬1è¡Œï¼šæŠ˜çº¿å›¾å ä¸¤åˆ—ï¼›æœ€æ–°æŒ‡æ ‡å ä¸€åˆ—
        if (lineCard){ lineCard.style.gridColumn = '1 / span 2'; lineCard.style.gridRow = '1 / span 1'; }
        if (statsCard){ statsCard.style.gridColumn = '3 / span 1'; statsCard.style.gridRow = '1 / span 1'; }
        // ç¬¬2è¡Œï¼šä¸‰ä¸ªä»ªè¡¨ç›˜åˆ†åˆ—ï¼ˆæ›´å°ï¼‰
        if (g1Card){ g1Card.style.gridColumn = '1 / span 1'; g1Card.style.gridRow = '2 / span 1'; }
        if (g2Card){ g2Card.style.gridColumn = '2 / span 1'; g2Card.style.gridRow = '2 / span 1'; }
        if (g3Card){ g3Card.style.gridColumn = '3 / span 1'; g3Card.style.gridRow = '2 / span 1'; }
        // ç¬¬3è¡Œï¼š.cur_input è·¨ä¸‰åˆ—
        if (curCardEl){ curCardEl.style.gridColumn = '1 / span 3'; curCardEl.style.gridRow = '3 / span 1'; }
      } else {
        // ç«–å±ï¼šä¿ç•™åŸæœ‰ 2 åˆ— Ã— 4 è¡Œå¸ƒå±€
        mainGrid.style.gridTemplateColumns = '1fr 1fr';
        mainGrid.style.gridTemplateRows    = '1.2fr 0.9fr 0.9fr 1fr';
        // ç¬¬1è¡Œï¼šæŠ˜çº¿å›¾è·¨ä¸¤åˆ—
        if (lineCard){ lineCard.style.gridColumn = '1 / span 2'; lineCard.style.gridRow = '1 / span 1'; }
        // ç¬¬2è¡Œï¼šä¸¤ä¸ªä»ªè¡¨ç›˜å„å ä¸€åŠ
        if (g1Card){ g1Card.style.gridColumn = '1 / span 1'; g1Card.style.gridRow = '2 / span 1'; }
        if (g2Card){ g2Card.style.gridColumn = '2 / span 1'; g2Card.style.gridRow = '2 / span 1'; }
        // ç¬¬3è¡Œï¼šå·¦ Execs/secï¼›å³ æœ€æ–°æŒ‡æ ‡
        if (g3Card){ g3Card.style.gridColumn = '1 / span 1'; g3Card.style.gridRow = '3 / span 1'; }
        if (statsCard){ statsCard.style.gridColumn = '2 / span 1'; statsCard.style.gridRow = '3 / span 1'; }
        // ç¬¬4è¡Œï¼š.cur_input è·¨ä¸¤åˆ—
        if (curCardEl){ curCardEl.style.gridColumn = '1 / span 2'; curCardEl.style.gridRow = '4 / span 1'; }
      }
      // é‡ç»˜å›¾è¡¨ä»¥é€‚é…
      lineChart.resize(); gauge1.resize(); gauge2.resize(); gauge3.resize();
    }
    mqLandscape.addEventListener ? mqLandscape.addEventListener('change', applyLayout) : mqLandscape.addListener(applyLayout);

    // ä¿æŒç”¨æˆ·å›¾ä¾‹é€‰æ‹©çŠ¶æ€ï¼Œé¿å…åˆ·æ–°åè¢«é‡ç½®ï¼›å¹¶åœ¨ç‚¹å‡»åçŸ­æš‚åœæ­¢è½®è¯¢ï¼Œé˜²æ­¢åˆ·æ–°æŠ¢å 
    // ä½¿ç”¨ localStorage æŒä¹…åŒ–å›¾ä¾‹é€‰æ‹©
    let legendSelected = null;
    try {
      const saved = localStorage.getItem('chiloPlotLegendSelected');
      if (saved) legendSelected = JSON.parse(saved);
    } catch(_) {}
    
    let pauseUntil = 0;
    lineChart.on('legendselectchanged', (e) => {
      legendSelected = Object.assign({}, e.selected);
      try {
        localStorage.setItem('chiloPlotLegendSelected', JSON.stringify(legendSelected));
      } catch(_) {}
      pauseUntil = Date.now() + 1000; // 1000ms äº¤äº’ä¿æŠ¤æ—¶é—´ï¼Œå¢åŠ åˆ°1ç§’
    });

    // åŠåœ†ä»ªè¡¨ç›˜é…ç½®ï¼Œæ›´å…·ç¾æ„Ÿ
    function gaugeOption(name, val, maxVal, colorStops, unit, scale){
      const v = Number.isFinite(val) ? val : 0;
      const m = Math.max(1, maxVal || 100);
      const sc = Number.isFinite(scale) ? scale : 1.0;
      const colors = colorStops || [[0.3, '#00f0ff'], [0.7, '#8b5cf6'], [1, '#ff006e']];
      const axisW = Math.round(14 * sc);
      const ptrW  = Math.max(3, Math.round(4 * sc));
      const fz    = Math.round(28 * sc);
      const titleFz = Math.round(13 * sc);
      return {
        animationDurationUpdate: 300,
        series: [{
          type: 'gauge',
          startAngle: 200,
          endAngle: -20,
          center: ['50%', sc > 1 ? '66%' : '60%'],
          radius: sc > 1 ? '92%' : '88%',
          min: 0,
          max: m,
          splitNumber: 5,
          pointer: { show: true, length: '62%', width: ptrW, itemStyle: { color: '#00f0ff' } },
          progress: { show: true, overlap: false, roundCap: true, clip: false, itemStyle: { color: '#00f0ff' } },
          axisLine: { lineStyle: { width: axisW, color: colors }},
          axisTick: { show: false },
          splitLine: { show: false },
          axisLabel: { show: false },
          title: { show: true, color: '#00f0ff', fontSize: titleFz, offsetCenter: [0,'70%'] },
          detail: {
            valueAnimation: true,
            fontSize: fz,
            color: '#00f0ff',
            offsetCenter: [0, sc > 1 ? '30%' : '35%'],
            formatter: (x) => unit ? `${x}${unit}` : `${x}`
          },
          data: [{ value: v, name }]
        }]
      };
    }

    function hueForAge(ageSec){
      if (ageSec <= 2) return 140;
      if (ageSec <= 5) return 105;
      if (ageSec <= 10) return 80;
      if (ageSec <= 20) return 60;
      if (ageSec <= 40) return 40;
      if (ageSec <= 60) return 25;
      if (ageSec <= 90) return 12;
      return 0;
    }
    // å‘å…‰å¼ºåº¦ï¼šæ—¶é—´è¶Šä¹…è¶Šäº®ï¼ˆä¸æ—¥å¿—é¡µç›¸åï¼‰
    function growGlow(ageSec){
      if (ageSec <= 2) return { blur: 2, alpha: 0.15 };
      if (ageSec <= 5) return { blur: 4, alpha: 0.25 };
      if (ageSec <= 10) return { blur: 6, alpha: 0.35 };
      if (ageSec <= 20) return { blur: 8, alpha: 0.45 };
      if (ageSec <= 40) return { blur: 10, alpha: 0.55 };
      if (ageSec <= 60) return { blur: 12, alpha: 0.65 };
      if (ageSec <= 90) return { blur: 14, alpha: 0.75 };
      return { blur: 18, alpha: 0.9 };
    }

    function fmtDuration(sec){
      const s = Math.max(0, Math.floor(sec||0));
      const h = Math.floor(s/3600), m = Math.floor((s%3600)/60), ss = s%60;
      const pad = (x)=> (x<10?('0'+x):(''+x));
      return h>0 ? `${pad(h)}:${pad(m)}:${pad(ss)}` : `${pad(m)}:${pad(ss)}`;
    }

    function renderAll(data){
      const meta = data.meta || {}; const s = data.series || {};
      currentChartData = s; // ä¿å­˜æ•°æ®ä¾›å¯¼å‡ºä½¿ç”¨
      const t = s.t || [];
      const map_size = s.map_size || [];
      const edges_found = s.edges_found || [];
      const corpus_count = s.corpus_count || [];
      const saved_crashes = s.saved_crashes || [];

      dataPathEl.textContent = meta.path ? ('æ–‡ä»¶ï¼š' + meta.path) : 'æœªæ‰¾åˆ° plot_data';
      metaEl.textContent = meta.exists ? (new Date(meta.mtime).toLocaleString() + ' Â· ' + (meta.size||0) + 'B') : 'ç­‰å¾…æ•°æ®â€¦';

      // æ›´ç¾è§‚çš„æŠ˜çº¿ï¼šé¢ç§¯æ¸å˜ + å…‰æ™• + å¹³æ»‘åŠ¨ç”»ï¼›ä¿ç•™ç”¨æˆ·å›¾ä¾‹é€‰æ‹©
      const opt = {
        backgroundColor: 'transparent',
        grid: { left: 60, right: 60, top: 50, bottom: 80 },
        animation: true,
        animationDuration: 600,
        animationEasing: 'quadraticOut',
        axisPointer: { link: [{ xAxisIndex: 'all' }], label: { backgroundColor: 'rgba(20,26,36,0.9)' } },
        tooltip: { trigger: 'axis', axisPointer: { type: 'line' } },
        legend: { 
          data: ['map_size(%)','edges_found','corpus_count','saved_crashes'], 
          selected: legendSelected || undefined, 
          top: null, 
          bottom: 15, 
          left: 'center', 
          itemWidth: 40, 
          itemHeight: 24, 
          itemGap: 30, 
          selectedMode: 'multiple', 
          textStyle: { fontSize: 16, color: '#2d2d2d', fontWeight: 500 },
          padding: [10, 20]
        },
        xAxis: {
          type: 'value',
          min: 'dataMin',
          max: 'dataMax',
          boundaryGap: false,
          axisLabel: { color: '#6b6b6b' },
          splitLine: { show: false }
        },
        yAxis: [
          {
            type: 'value', name: '%', position: 'left', scale: true,
            min: function(v){
              const min = Number.isFinite(v.min) ? v.min : 0;
              const max = Number.isFinite(v.max) ? v.max : (min+1);
              if (min === max) return Math.max(0, min - 1);
              const pad = Math.max(0.5, (max - min) * 0.1); // è‡³å°‘ 0.5 ä¸ªç™¾åˆ†ç‚¹ç•™ç™½
              return Math.max(0, min - pad);
            },
            max: function(v){
              const min = Number.isFinite(v.min) ? v.min : 0;
              const max = Number.isFinite(v.max) ? v.max : (min+1);
              if (min === max) return max + 1;
              const pad = Math.max(0.5, (max - min) * 0.1);
              return max + pad;
            },
            axisLabel: { formatter: '{value}%' }
          },
          {
            type: 'value', position: 'right', scale: true,
            min: function(v){
              const min = Number.isFinite(v.min) ? v.min : 0;
              const max = Number.isFinite(v.max) ? v.max : (min+1);
              if (min === max) return Math.max(0, min - 1);
              const pad = Math.max(1, (max - min) * 0.1); // è‡³å°‘ 1 çš„ç•™ç™½
              return Math.max(0, min - pad);
            },
            max: function(v){
              const min = Number.isFinite(v.min) ? v.min : 0;
              const max = Number.isFinite(v.max) ? v.max : (min+2);
              if (min === max) return max + 1;
              const pad = Math.max(1, (max - min) * 0.1);
              return max + pad;
            }
          },
          {
            type: 'value', position: 'right', scale: true, offset: 52,
            min: function(v){
              const min = Number.isFinite(v.min) ? v.min : 0;
              const max = Number.isFinite(v.max) ? v.max : (min+1);
              if (min === max) return Math.max(0, min - 1);
              const pad = Math.max(1, (max - min) * 0.1);
              return Math.max(0, min - pad);
            },
            max: function(v){
              const min = Number.isFinite(v.min) ? v.min : 0;
              const max = Number.isFinite(v.max) ? v.max : (min+2);
              if (min === max) return max + 1;
              const pad = Math.max(1, (max - min) * 0.1);
              return max + pad;
            }
          },
          {
            type: 'value', position: 'right', scale: true, offset: 104,
            min: function(v){
              const min = Number.isFinite(v.min) ? v.min : 0;
              const max = Number.isFinite(v.max) ? v.max : (min+1);
              if (min === max) return Math.max(0, min - 1);
              const pad = Math.max(1, (max - min) * 0.1);
              return Math.max(0, min - pad);
            },
            max: function(v){
              const min = Number.isFinite(v.min) ? v.min : 0;
              const max = Number.isFinite(v.max) ? v.max : (min+2);
              if (min === max) return max + 1;
              const pad = Math.max(1, (max - min) * 0.1);
              return max + pad;
            }
          }
        ],
        series: [
          {
            name: 'map_size(%)', type: 'line', yAxisIndex: 0, smooth: true, showSymbol: false, data: t.map((ti,i)=>[ti, map_size[i]]),
            lineStyle:{ color:'#00f0ff', width: 3 },
            areaStyle:{
              opacity: 0.25,
              color: new echarts.graphic.LinearGradient(0,0,0,1,[{ offset:0, color:'rgba(0,240,255,0.4)'},{ offset:1, color:'rgba(0,240,255,0.05)'}])
            },
            emphasis: { focus: 'series' }
          },
          {
            name: 'edges_found', type: 'line', yAxisIndex: 1, smooth: true, showSymbol: false, data: t.map((ti,i)=>[ti, edges_found[i]]),
            lineStyle:{ color:'#8b5cf6', width: 3 },
            areaStyle:{ opacity: 0.25, color: new echarts.graphic.LinearGradient(0,0,0,1,[{offset:0,color:'rgba(139,92,246,0.4)'},{offset:1,color:'rgba(139,92,246,0.05)'}]) }
          },
          {
            name: 'corpus_count', type: 'line', yAxisIndex: 2, smooth: true, showSymbol: false, data: t.map((ti,i)=>[ti, corpus_count[i]]),
            lineStyle:{ color:'#ff006e', width: 3 },
            areaStyle:{ opacity: 0.25, color: new echarts.graphic.LinearGradient(0,0,0,1,[{offset:0,color:'rgba(255,0,110,0.4)'},{offset:1,color:'rgba(255,0,110,0.05)'}]) }
          },
          {
            name: 'saved_crashes', type: 'line', yAxisIndex: 3, smooth: true, showSymbol: false, data: t.map((ti,i)=>[ti, saved_crashes[i]]),
            lineStyle:{ color:'#ffed4e', width: 3 },
            areaStyle:{ opacity: 0.25, color: new echarts.graphic.LinearGradient(0,0,0,1,[{offset:0,color:'rgba(255,237,78,0.4)'},{offset:1,color:'rgba(255,237,78,0.05)'}]) }
          }
        ]
      };
      if (legendSelected) {
        opt.legend.selected = legendSelected;
      }
      lineChart.setOption(opt, { notMerge: false, lazyUpdate: true });
      // å›è¯»ä¸€æ¬¡ï¼Œç¡®ä¿è·å–ç”¨æˆ·æœ€æ–°é€‰æ‹©çŠ¶æ€ï¼ˆåŒ…æ‹¬å¤–éƒ¨äº¤äº’ï¼‰
      try {
        const optNow = lineChart.getOption();
        if (optNow && optNow.legend && optNow.legend.length && optNow.legend[0].selected) {
          legendSelected = Object.assign({}, optNow.legend[0].selected);
        }
      } catch(_) {}

      const lastIdx = t.length ? t.length - 1 : -1;
      const latest = (k) => (s[k] && lastIdx>=0 ? s[k][lastIdx] : 0);

      // ä»ªè¡¨ï¼šæ ¹æ®å½“å‰å€¼åŠ¨æ€è®¾ç½®ä¸Šé™ï¼Œä½¿æŒ‡é’ˆæœ‰å¯Œä½™ç©ºé—´ï¼›æ¨ªå±æŒ‰å¡ç‰‡é«˜åº¦åŠ¨æ€ç¼©æ”¾
      function gaugeScaleFor(card){
        try{
          const h = card ? card.clientHeight : 0;
          if (!h || !Number.isFinite(h)) return (mqLandscape.matches ? 1.15 : 0.95);
          if (mqLandscape.matches){
            // æ¨ªå±ï¼šç•¥æ”¾å¤§ï¼Œä½†æ§åˆ¶ä¸Šé™ï¼Œé¿å…è¿‡å¤§é®æŒ¡
            return Math.max(1.05, Math.min(1.5, h / 340));
          } else {
            // ç«–å±ï¼šæ•´ä½“ç¨å¾®ç¼©å°ä¸€ç‚¹ç‚¹ï¼Œç•™å‡ºæ›´å¤šç©ºé—´
            return Math.max(0.85, Math.min(1.4, h / 360));
          }
        }catch(_){ return (mqLandscape.matches ? 1.15 : 0.95); }
      }
      const sc1 = gaugeScaleFor(g1Card);
      const sc2 = gaugeScaleFor(g2Card);
      const sc3 = gaugeScaleFor(g3Card);
      gauge1.setOption(gaugeOption('pending_total', latest('pending_total'), Math.max(10, latest('pending_total')*1.6), undefined, '', sc1));
      gauge2.setOption(gaugeOption('pending_favs', latest('pending_favs'), Math.max(10, latest('pending_favs')*1.6), undefined, '', sc2));
      gauge3.setOption(gaugeOption('execs_per_sec', latest('execs_per_sec'), Math.max(50, latest('execs_per_sec')*1.6), [[0.3,'#00ff9f'],[0.7,'#00f0ff'],[1,'#8b5cf6']], '', sc3));

      const setStat = (id, val) => { const el = document.querySelector('#'+id+' .stat-value'); if (el) el.textContent = (val ?? 'â€”'); };
      setStat('s_cycles', latest('cycles_done'));
      setStat('s_cur_item', latest('cur_item'));
      setStat('s_saved_crashes', latest('saved_crashes'));
      setStat('s_max_depth', latest('max_depth'));
      setStat('s_total_execs', latest('total_execs'));

      // æ¸²æŸ“ .cur_input
      const cur = (data && data.cur_input) ? data.cur_input : null;
      const card = document.getElementById('curCard');
      const metaBox = document.getElementById('curMeta');
      const cont = document.getElementById('curContent');
      const timerBox = document.getElementById('curTimer');
      if (cur && card && cont && metaBox && timerBox){
        const m = cur.meta || {};
        const txt = (cur.content || '').replace(/^\uFEFF/, '');
        metaBox.textContent = m.exists ? `${m.path} Â· ${m.size||0}B Â· ${new Date(m.mtime||Date.now()).toLocaleString()}` : 'æœªæ‰¾åˆ° .cur_input';
        timerBox.textContent = m.exists ? ('å·²è¿è¡Œ ' + fmtDuration(cur.since_sec||0)) : 'â€”';

        // å†…å®¹å±•ç¤ºï¼šæ ¹æ®é•¿åº¦ä¸æ–¹å‘è‡ªåŠ¨åˆ‡æ¢åˆ—æ•°ï¼ˆæ— æ¨ªå‘æ»šåŠ¨ï¼Œä¸æˆªæ–­ï¼‰
        const lines = txt.split(/\r?\n/);
        const isLandscape = mqLandscape.matches;
        let cols = (lines.length >= 120 || txt.length > 8000) ? 3 : ((lines.length >= 30 || txt.length > 1500) ? 2 : 1);
        // è¦æ±‚ï¼šç«–å±ä¹Ÿåº”æ˜¾ç¤ºåŒæ ï¼Œå› æ­¤åœ¨ç«–å±ä¸‹è‡³å°‘ 2 æ ï¼›æ¨ªå±è‡³å°‘ 2 æ 
        cols = Math.max(cols, 2);
        cont.style.columnCount = cols;
        cont.innerText = txt || 'ï¼ˆç©ºï¼‰';

        // è¾¹æ¡†ä¸å‘å…‰ï¼šæ—¶é—´è¶Šä¹…è¶Šçº¢ã€è¶Šäº®ï¼ˆæ—¥å¼ç®€çº¦ç‰ˆ - é™ä½æ•ˆæœï¼‰
        const age = Math.max(0, cur.since_sec||0);
        const h = hueForAge(age);
        const glow = growGlow(age);
        const border = `hsl(${h}, 40%, 65%)`;
        const outer = `0 0 ${Math.round(glow.blur*0.5)}px hsla(${h}, 40%, 55%, ${glow.alpha*0.3})`;
        card.style.borderColor = border;
        card.style.boxShadow = outer;
      }
    }

    async function fetchPlot(){
      try{
        if (Date.now() < pauseUntil) return; // äº¤äº’ä¿æŠ¤ï¼šæš‚åœè½®è¯¢ï¼Œé¿å…è¦†ç›–å›¾ä¾‹ç‚¹å‡»
        const r = await fetch('/api/plot?t=' + Date.now(), { cache: 'no-store' });
        const data = await r.json();
        renderAll(data);
      }catch(e){ console.error(e); }
    }

    function start(){ stop(); timer = setInterval(fetchPlot, interval); }
    function stop(){ if (timer) { clearInterval(timer); timer=null; } }

    intervalSel.addEventListener('change', () => {
      interval = parseInt(intervalSel.value,10)||100;
      localStorage.setItem('cd_plot_interval', intervalSel.value);
      start();
    });
    window.addEventListener('resize', () => { applyLayout(); });

    applyLayout();
    fetchPlot();
    start();

    // ========== å¯¼å‡ºåŠŸèƒ½ ==========
    let currentChartData = null; // ä¿å­˜å½“å‰å›¾è¡¨æ•°æ®

    // å¯¼å‡ºä¸‹æ‹‰èœå•æ§åˆ¶
    const exportBtn = document.getElementById('exportBtn');
    const exportDropdown = document.getElementById('exportDropdown');
    let dropdownVisible = false;

    exportBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      dropdownVisible = !dropdownVisible;
      exportDropdown.style.display = dropdownVisible ? 'block' : 'none';
    });

    document.addEventListener('click', () => {
      dropdownVisible = false;
      exportDropdown.style.display = 'none';
    });

    // å¯¼å‡ºå›¾è¡¨ä¸º PNG
    window.exportChart = function() {
      const url = lineChart.getDataURL({
        type: 'png',
        pixelRatio: 2,
        backgroundColor: '#0a0e1a'
      });
      const a = document.createElement('a');
      a.href = url;
      a.download = `chilodisco_chart_${new Date().getTime()}.png`;
      a.click();
      window.ChiloDisco?.toast?.success('å›¾è¡¨å¯¼å‡ºæˆåŠŸï¼');
      dropdownVisible = false;
      exportDropdown.style.display = 'none';
    };

    // å¯¼å‡ºæ•°æ®ä¸º CSV
    window.exportData = function() {
      if (!currentChartData) {
        window.ChiloDisco?.toast?.warning('æš‚æ— æ•°æ®å¯å¯¼å‡ºï¼');
        return;
      }

      const series = currentChartData;
      const len = series.t?.length || 0;
      if (len === 0) {
        window.ChiloDisco?.toast?.warning('æš‚æ— æ•°æ®å¯å¯¼å‡ºï¼');
        return;
      }

      // æ„å»º CSV å†…å®¹
      const headers = [
        'Time(s)',
        'Map Size(%)',
        'Edges Found',
        'Corpus Count',
        'Cycles Done',
        'Current Item',
        'Saved Crashes',
        'Max Depth',
        'Total Execs',
        'Pending Total',
        'Pending Favs',
        'Execs/Sec'
      ];

      let csv = headers.join(',') + '\\n';

      for (let i = 0; i < len; i++) {
        const row = [
          series.t[i] || 0,
          series.map_size[i] || 0,
          series.edges_found[i] || 0,
          series.corpus_count[i] || 0,
          series.cycles_done[i] || 0,
          series.cur_item[i] || 0,
          series.saved_crashes[i] || 0,
          series.max_depth[i] || 0,
          series.total_execs[i] || 0,
          series.pending_total[i] || 0,
          series.pending_favs[i] || 0,
          series.execs_per_sec[i] || 0
        ];
        csv += row.join(',') + '\\n';
      }

      // ä¸‹è½½ CSV
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `chilodisco_data_${new Date().getTime()}.csv`;
      a.click();
      URL.revokeObjectURL(url);

      window.ChiloDisco?.toast?.success('CSV æ•°æ®å¯¼å‡ºæˆåŠŸï¼');
      dropdownVisible = false;
      exportDropdown.style.display = 'none';
    };

    // å¯¼å‡ºå…¨éƒ¨ï¼ˆå›¾è¡¨+æ•°æ®ï¼‰
    window.exportAll = function() {
      exportChart();
      setTimeout(() => exportData(), 300);
    };

    // éœ“è™¹ç²’å­ç‰¹æ•ˆ - é«˜å¯†åº¦å¯è§ç‰ˆ
    (function() {
      const canvas = document.getElementById('globalParticles');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      
      function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
      }
      resize();
      
      const particles = [];
      const N = Math.max(80, Math.floor((canvas.width * canvas.height) / 8000));
      
      const colors = [
        { r: 0, g: 240, b: 255 },    // éœ“è™¹é’
        { r: 139, g: 92, b: 246 },   // éœ“è™¹ç´«
        { r: 255, g: 0, b: 110 },    // éœ“è™¹ç²‰
        { r: 0, g: 255, b: 159 }     // éœ“è™¹ç»¿
      ];
      
      for (let i = 0; i < N; i++) {
        const color = colors[Math.floor(Math.random() * colors.length)];
        particles.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          r: Math.random() * 2 + 1,
          vx: (Math.random() - 0.5) * 0.5,
          vy: (Math.random() - 0.5) * 0.5,
          color: color,
          alpha: Math.random() * 0.6 + 0.4,
          phase: Math.random() * Math.PI * 2,
          speed: Math.random() * 0.03 + 0.01
        });
      }
      
      function animate() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        for (const p of particles) {
          p.x += p.vx;
          p.y += p.vy;
          p.phase += p.speed;
          
          if (p.x < -10) p.x = canvas.width + 10;
          if (p.x > canvas.width + 10) p.x = -10;
          if (p.y < -10) p.y = canvas.height + 10;
          if (p.y > canvas.height + 10) p.y = -10;
          
          const glow = 0.6 + 0.4 * Math.sin(p.phase);
          const glowRadius = p.r * 4 * glow;
          
          // å¤–å±‚å‘å…‰
          const grad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, glowRadius);
          grad.addColorStop(0, `rgba(${p.color.r}, ${p.color.g}, ${p.color.b}, ${p.alpha * glow})`);
          grad.addColorStop(0.4, `rgba(${p.color.r}, ${p.color.g}, ${p.color.b}, ${p.alpha * glow * 0.5})`);
          grad.addColorStop(1, `rgba(${p.color.r}, ${p.color.g}, ${p.color.b}, 0)`);
          
          ctx.fillStyle = grad;
          ctx.beginPath();
          ctx.arc(p.x, p.y, glowRadius, 0, Math.PI * 2);
          ctx.fill();
          
          // æ ¸å¿ƒäº®ç‚¹
          ctx.fillStyle = `rgba(${p.color.r}, ${p.color.g}, ${p.color.b}, ${p.alpha * glow})`;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
          ctx.fill();
        }
        
        requestAnimationFrame(animate);
      }
      
      animate();
      window.addEventListener('resize', () => {
        resize();
      });
      
      if (window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      }
    })();
  </script>
</body>
</html>
