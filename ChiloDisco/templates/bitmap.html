<!doctype html>
<html lang="zh-CN">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Bitmap Visualizer ¬∑ ChiloDisco</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/static/css/styles.css">
    <style>
        /* Scoped styles for scrollable large grid */
        body {
            overflow: hidden;
        }

        /* Let main-content handle scroll */

        .toolbar {
            flex-shrink: 0;
            margin-bottom: 0 !important;
            border-bottom: 1px solid var(--glass-border);
            z-index: 10;
        }

        .scroll-container {
            flex: 1;
            overflow: auto;
            /* Enable scrolling for large canvas */
            position: relative;
            background: rgba(0, 0, 0, 0.3);
            display: flex;
            justify-content: flex-start;
            /* Align top-left */
            align-items: flex-start;
            padding: 20px;
            cursor: default;
        }

        canvas {
            display: block;
            image-rendering: pixelated;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            /* Remove width/height: 100% to allow natural size */
        }

        .tooltip {
            position: fixed;
            /* Fixed relative to viewport to avoid scroll issues */
            background: rgba(15, 23, 42, 0.95);
            color: #fff;
            padding: 6px 10px;
            border-radius: 4px;
            pointer-events: none;
            font-size: 12px;
            font-family: 'JetBrains Mono', monospace;
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(4px);
            z-index: 1000;
            display: none;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }
    </style>
</head>

<body>

    <div class="app-layout">
        <aside class="sidebar">
            <div class="brand">
                <span class="brand-icon">‚ö°</span>
                <span>ChiloDisco</span>
            </div>
            <nav class="nav-menu">
                <a href="/" class="nav-item"><span>üìä Êó•ÂøóÁõëÊéß</span></a>
                <a href="/plot" class="nav-item"><span>üìà Êï∞ÊçÆÂ§ßÂ±è</span></a>
                <a href="/bitmap" class="nav-item active"><span>üó∫Ô∏è Bitmap ÁÉ≠ÂäõÂõæ</span></a>
                <a href="/downloads" class="nav-item"><span>üíæ ÁªìÊûú‰∏ãËΩΩ</span></a>
                <a href="/settings" class="nav-item"><span>‚öôÔ∏è Á≥ªÁªüËÆæÁΩÆ</span></a>
            </nav>
        </aside>

        <main class="main-content" style="display:flex; flex-direction:column; height:100vh; overflow:hidden;">

            <!-- Toolbar -->
            <div class="toolbar glass-panel" style="border-radius:0;">
                <div class="flex-row justify-between items-center w-full">
                    <div class="flex-row items-center gap-4">
                        <h2 style="margin:0;">Bitmap Visualizer</h2>
                        <span id="status-tag" class="badge" style="background:#22c55e20; color:#22c55e;">LIVE</span>
                    </div>

                    <div class="flex-row gap-4 items-center">
                        <div class="flex-row gap-2">
                            <button class="btn btn-glass channel-btn active" data-channel="sum">Sum</button>
                            <button class="btn btn-glass channel-btn" data-channel="cumulative">Cumulative</button>
                            <button class="btn btn-glass channel-btn" data-channel="bool">Bool</button>
                        </div>

                        <div class="flex-row items-center gap-2 text-sm text-muted">
                            <span>Zoom:</span>
                            <input type="range" id="zoom-slider" min="4" max="32" value="12" step="2"
                                style="width:100px;">
                            <span id="zoom-val">12px</span>
                        </div>

                        <div class="flex-row items-center gap-2 text-sm text-muted">
                            <span>Palette:</span>
                            <select id="color-palette"
                                style="background:rgba(0,0,0,0.3); border:none; color:inherit; padding:2px;">
                                <option value="inferno" selected>Inferno</option>
                                <option value="viridis">Viridis</option>
                                <option value="magma">Magma</option>
                                <option value="neon">Neon</option>
                            </select>
                        </div>

                        <button class="btn btn-primary" onclick="downloadImage()" title="Save as PNG">
                            üì∑ Êà™Âõæ‰øùÂ≠ò
                        </button>
                        <button class="btn btn-primary" onclick="downloadAll()">
                            üì• ‰∏ãËΩΩÂÖ®ÈÉ®
                        </button>
                    </div>
                </div>
                <div class="flex-row justify-between text-xs text-muted mt-2">
                    <span id="map-info">Map: - | Size: -</span>
                    <span id="render-stats">FPS: 60 | Active: 0</span>
                </div>
            </div>

            <!-- Scrollable Canvas Container -->
            <div class="scroll-container" id="canvas-wrapper">
                <canvas id="bitmap-canvas"></canvas>
                <!-- Highlight Box (Simple border) -->
                <div id="highlight-box"
                    style="position:absolute; border:2px solid #fff; pointer-events:none; display:none; box-shadow:0 0 8px white;">
                </div>
            </div>

            <div id="tooltip" class="tooltip"></div>

        </main>
    </div>

    <!-- Auto-Wrap / Ripple / Download Logic -->
    <script>
        const CONFIG = {
            api: '/api/bitmap/frame',
            colors: {
                inferno: [[0, 0, 4], [32, 11, 75], [87, 16, 109], [152, 45, 128], [211, 67, 104], [248, 118, 92], [254, 188, 43], [252, 255, 164]],
                viridis: [[68, 1, 84], [70, 50, 126], [54, 92, 141], [39, 127, 142], [31, 161, 135], [74, 193, 109], [160, 218, 57], [253, 231, 37]],
                magma: [[0, 0, 4], [34, 17, 80], [95, 24, 127], [152, 45, 128], [227, 89, 120], [252, 142, 93], [252, 217, 133], [252, 253, 191]],
                neon: [[15, 23, 42], [14, 165, 233], [139, 92, 246], [236, 72, 153], [244, 63, 94]]
            }
        };

        let state = {
            data: null,
            prevData: null,
            decayBuffer: null,      // Float32Array [0..1]
            activeIndices: new Set(),
            ripples: [],            // {x, y, r, alpha, color}
            channel: 'sum',
            palette: 'inferno',
            cellSize: 12,
            renderCols: 0,          // Calculated based on width
            renderRows: 0,
            running: true,
            timer: null
        };

        const canvas = document.getElementById('bitmap-canvas');
        const ctx = canvas.getContext('2d', { alpha: false });
        const tooltip = document.getElementById('tooltip');
        const highlight = document.getElementById('highlight-box');
        const wrapper = document.getElementById('canvas-wrapper');

        // --- Color Helper ---
        function getBaseColor(val, minVal, maxVal, paletteName) {
            const pal = CONFIG.colors[paletteName] || CONFIG.colors.inferno;
            if (maxVal === minVal) return pal[0]; // Base color

            let t = (state.channel === 'bool') ? (val > 0 ? 1 : 0) : Math.max(0, Math.min(1, (val - minVal) / (maxVal - minVal)));
            const idx = t * (pal.length - 1);
            const i = Math.floor(idx);
            const j = Math.min(i + 1, pal.length - 1);
            const ratio = idx - i;
            const c1 = pal[i];
            const c2 = pal[j];
            return [
                (c1[0] + (c2[0] - c1[0]) * ratio) | 0,
                (c1[1] + (c2[1] - c1[1]) * ratio) | 0,
                (c1[2] + (c2[2] - c1[2]) * ratio) | 0
            ];
        }

        // --- Layout Calculation ---
        function updateLayout() {
            if (!state.data) return;

            // Read container width (minus padding)
            const availW = wrapper.clientWidth - 40;

            // Calculate columns that fit
            const cols = Math.floor(availW / state.cellSize);
            state.renderCols = Math.max(1, cols);

            // Calculate required rows
            state.renderRows = Math.ceil(state.data.mapSize / state.renderCols);

            // Resize Canvas
            canvas.width = state.renderCols * state.cellSize;
            canvas.height = state.renderRows * state.cellSize;

            // Reset visual state (full redraw)
            ctx.fillStyle = '#0f172a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            // Mark all active to redraw content
            for (let i = 0; i < state.data.mapSize; i++) {
                state.activeIndices.add(i);
            }

            document.getElementById('map-info').textContent = `Map: ${state.data.mapSize} | Layout: ${state.renderCols} cols`;
        }

        // --- Core Logic ---
        async function fetchData() {
            try {
                const res = await fetch(CONFIG.api);
                const json = await res.json();
                if (!json.ok) return;

                // Init
                if (!state.data || state.data.mapSize !== json.mapSize) {
                    state.decayBuffer = new Float32Array(json.mapSize);
                    state.data = json; // Set data first for layout
                    state.activeIndices.clear();
                    updateLayout();    // Calc layout
                }

                const curChan = json.channels[state.channel] || [];
                const prevChan = state.data ? (state.data.channels[state.channel] || []) : null;

                // Diff
                if (curChan.length > 0) {
                    if (!prevChan) {
                        // First load: all active?
                        // No, just render.
                    } else {
                        for (let i = 0; i < curChan.length; i++) {
                            if (curChan[i] !== prevChan[i]) {
                                state.decayBuffer[i] = 1.0; // Flash
                                state.activeIndices.add(i);

                                // Spawn Ripple (Limit count)
                                if (Math.random() > 0.7 && state.ripples.length < 50) {
                                    const c = i % state.renderCols;
                                    const r = Math.floor(i / state.renderCols);
                                    state.ripples.push({
                                        x: c * state.cellSize + state.cellSize / 2,
                                        y: r * state.cellSize + state.cellSize / 2,
                                        r: 0,
                                        a: 1.0,
                                        color: getBaseColor(curChan[i], 0, 255, state.palette) // approx color
                                    });
                                }
                            }
                        }
                    }
                }

                state.prevData = state.data;
                state.data = json;

            } catch (e) {
                console.error(e);
            }
        }

        // --- Render Loop ---
        function renderLoop() {
            if (!state.running) return;
            requestAnimationFrame(renderLoop);

            if (!state.data) return;

            const chanData = state.data.channels[state.channel];
            const pal = state.palette;
            const size = state.cellSize;
            const gap = size > 4 ? 1 : 0;
            const innerSize = size - gap;
            const decayRate = 0.05;

            // 1. Draw Active Cells
            // Note: We need to clear cells before redrawing? 
            // fillRect covers opaque, so it's fine.
            // But decay needs to blend with BG?
            // Logic: fill BG then draw Color? Or just Computed Color.
            // Computed Color: Base * (1-decay) + Flash * decay.
            // If Base is 0 (BG), then BG * (1-decay) + Flash * decay.

            // Get MaxVal for Color Scale
            let maxV = 255;

            const removeList = [];
            for (const i of state.activeIndices) {
                const val = chanData[i];
                const decay = state.decayBuffer[i];

                const row = Math.floor(i / state.renderCols);
                const col = i % state.renderCols;
                const x = col * size;
                const y = row * size;

                // Base Color
                const base = getBaseColor(val, 0, maxV, pal);

                // Mix Flash (White)
                const r = (base[0] * (1 - decay) + 255 * decay) | 0;
                const g = (base[1] * (1 - decay) + 255 * decay) | 0;
                const b = (base[2] * (1 - decay) + 255 * decay) | 0;

                ctx.fillStyle = `rgb(${r},${g},${b})`;
                ctx.fillRect(x, y, innerSize, innerSize);

                if (decay > 0.01) {
                    state.decayBuffer[i] *= (1 - decayRate);
                } else {
                    state.decayBuffer[i] = 0;
                    // Determine if we can stop updating
                    // If static value, we don't need to redraw (it's painted).
                    state.activeIndices.delete(i);
                    // Wait, Set iteration is safe? new Set(state.activeIndices) was not used.
                    // Standard JS Set iteration allows deletion.
                }
            }

            // 2. Draw Ripples (global effects layer?)
            // Since canvas is single layer, ripples might overwrite cells or be overwritten.
            // To look good, ripples should be multiplicative or additive?
            // Canvas 2D is painter's alg.
            // If we draw ripples ON TOP, they obscure text/cells.
            // Let's use `globalCompositeOperation = 'lighter'` for glow.

            if (state.ripples.length > 0) {
                ctx.save();
                ctx.globalCompositeOperation = 'lighter'; // Additive blend
                ctx.lineWidth = 2;

                for (let i = state.ripples.length - 1; i >= 0; i--) {
                    const rp = state.ripples[i];
                    ctx.beginPath();
                    ctx.strokeStyle = `rgba(100, 255, 255, ${rp.a})`;
                    ctx.arc(rp.x, rp.y, rp.r, 0, Math.PI * 2);
                    ctx.stroke();

                    rp.r += 0.5;  // expand
                    rp.a -= 0.02; // fade

                    if (rp.a <= 0) {
                        state.ripples.splice(i, 1);
                    }
                }
                ctx.restore();
            }

            document.getElementById('render-stats').textContent = `ACT: ${state.activeIndices.size} | RIP: ${state.ripples.length}`;
        }

        // --- Interaction ---
        document.getElementById('zoom-slider').addEventListener('input', (e) => {
            state.cellSize = parseInt(e.target.value);
            document.getElementById('zoom-val').textContent = state.cellSize + 'px';
            updateLayout();
        });

        window.addEventListener('resize', () => {
            // Debounce?
            setTimeout(updateLayout, 100);
        });

        // Hover
        wrapper.addEventListener('mousemove', (e) => {
            if (!state.data) return;
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;

            if (mx < 0 || my < 0 || mx > rect.width || my > rect.height) {
                highlight.style.display = 'none';
                tooltip.style.display = 'none';
                return;
            }

            const c = Math.floor(mx / state.cellSize);
            const r = Math.floor(my / state.cellSize);
            const idx = r * state.renderCols + c;

            if (idx >= 0 && idx < state.data.mapSize) {
                highlight.style.display = 'block';
                highlight.style.width = state.cellSize + 'px';
                highlight.style.height = state.cellSize + 'px';
                // We need relative pos to wrapper...
                // Wrapper is scrollable. Canvas is inside. 
                // `rect` is canvas viewport rect.
                // Highlight is absolute in Wrapper.
                // canvas.offsetLeft should work.

                // Actually, simpler:
                // Set highlight position relative to mouse but snapped?
                // No, must be relative to canvas origin.
                // Wrapper is `position: relative`. Canvas is normal flow.
                // highlight `position: absolute`.
                // Note: .scroll-container has padding: 20px. 
                // The canvas starts at 20, 20 inside the wrapper.
                // Our calculated c, r are 0-based relative to canvas.
                // So the highlight box, also absolute in wrapper, needs to be offset by 20px.
                const pad = 20;
                highlight.style.left = (c * state.cellSize + pad) + 'px';
                highlight.style.top = (r * state.cellSize + pad) + 'px';

                const val = state.data.channels[state.channel][idx];
                tooltip.style.display = 'block';
                tooltip.style.left = (e.clientX + 15) + 'px';
                tooltip.style.top = (e.clientY + 15) + 'px';
                tooltip.innerHTML = `<span style="color:#aaa">IDX:</span> <b>${idx}</b> <br> <span style="color:#aaa">VAL:</span> <b style="color:var(--accent-primary)">${val}</b>`;
            }
        });

        wrapper.addEventListener('mouseleave', () => {
            highlight.style.display = 'none';
            tooltip.style.display = 'none';
        });

        // Image Download
        function downloadImage() {
            const link = document.createElement('a');
            link.download = `bitmap_${state.channel}_${Date.now()}.png`;
            link.href = canvas.toDataURL();
            link.click();
        }

        // Allow global access for inline onclick
        window.downloadImage = downloadImage;
        window.downloadAll = function () {
            window.location.href = '/api/download/bitmap/all';
        };

        // Re-bind controls
        document.querySelectorAll('.channel-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
                document.querySelectorAll('.channel-btn').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                state.channel = e.target.dataset.channel;
                // refresh
                if (state.data) {
                    for (let i = 0; i < state.data.mapSize; i++) state.activeIndices.add(i);
                }
            });
        });

        document.getElementById('color-palette').addEventListener('change', (e) => {
            state.palette = e.target.value;
            if (state.data) for (let i = 0; i < state.data.mapSize; i++) state.activeIndices.add(i);
        });

        // Init
        startPoll();
        requestAnimationFrame(renderLoop);

        function startPoll() {
            if (state.timer) clearInterval(state.timer);
            state.timer = setInterval(fetchData, 1000);
            fetchData();
        }
    </script>
</body>

</html>